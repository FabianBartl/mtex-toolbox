---
title: Crystal Directions
last_updated: 02-Oct-2019
sidebar: documentation_sidebar
permalink: Miller_index.html
folder: documentation
toc: false
---

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Crystal Directions</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-10-02"><meta name="DC.source" content="script_Miller_index.m"></head><body><font size="2"><a href="#" data-toggle="tooltip" data-original-title="To edit this page type edit Miller_index into the Matlab commandline">edit page</a></font><div><!--introduction--><p>This section describes the class <b>Miller</b> and gives an overview how to deal with crystal directions in MTEX.</p><!--/introduction--><h2 id="1">Class Description</h2><p>Crystal directions are represented in MTEX by the variables of the class <b>Miller</b> which in turn represent a direction with respect to the crystal coordinate system described  by three or four values h, l, k (,m) and a <a href="crystalSymmetry_index.html">crystall symmetry</a>. Essentially all operations defined for the [[vector3d_index.html,vector3d]] class are also available for Miller indices. Furthermore, You can ask for all crystallographically equivalent crystal directions to one Miller index.</p><h2 id="2">SUB: Defining Miller indices</h2><p>Miller indices are defined by three coordinates h, k, l (four in the case of trigonal or hexagonal crystal symmetry) and by the corresponding symmetry class. It is also possible to convert a vector3d object into a Miller index.</p><pre class="codeinput">cs = crystalSymmetry(<span class="string">'trigonal'</span>);
m = Miller(1,0,-1,1,cs)
m = Miller(zvector,cs)
</pre><pre class="codeoutput"> 
m = Miller  
 size: 1 x 1
 symmetry: -31m, X||a*, Y||b, Z||c*
  h  1
  k  0
  i -1
  l  1
 
m = Miller  
 size: 1 x 1
 symmetry: -31m, X||a*, Y||b, Z||c*
  h 0
  k 0
  i 0
  l 1
</pre><h2 id="3">SUB: Plotting Miller indices</h2><p>Miller indices are plotted as spherical projections. The specific projection as well as whether to plot all equivalent directions can be specified by options.</p><pre class="codeinput">plot(Miller(2,1,-3,1,cs))   <span class="comment">% plot Miller indices</span>
</pre>
  {% include inline_image.html file="Miller_index_01.png" %}
<p>By providing the options <b>all</b> and <b>labeled</b> all symmetrically equivalent crystal directions are plotted together with their correct Miller indices.</p><pre class="codeinput">plot(Miller(2,1,-3,1,cs),<span class="string">'all'</span>,<span class="string">'labeled'</span>)   <span class="comment">% plot Miller indices</span>
</pre>
  {% include inline_image.html file="Miller_index_02.png" %}
<h2 id="5">SUB: Symmetrically Equivalent Crystal Directions</h2><p>A simple way to compute all symmetrically equivalent directions to a given crystal direction is provided by the command <a href="Miller.symmetrise.html">symmetrise</a></p><pre class="codeinput">m = Miller(1,1,-2,0,cs)
symmetrise(m)
</pre><pre class="codeoutput"> 
m = Miller  
 size: 1 x 1
 symmetry: -31m, X||a*, Y||b, Z||c*
  h  1
  k  1
  i -2
  l  0
 
ans = Miller  
 size: 6 x 1
 symmetry: -31m, X||a*, Y||b, Z||c*
  h  1 -1 -2 -1  1  2
  k  1 -1  1  2 -2 -1
  i -2  2  1 -1  1 -1
  l  0  0  0  0  0  0
</pre><p>As always the keyword <a href="AxialDirectional.html">antipodal</a> adds antipodal symmetry to this computation</p><pre class="codeinput">symmetrise(m,<span class="string">'antipodal'</span>)
</pre><pre class="codeoutput"> 
ans = Miller  
 size: 6 x 1
 symmetry: -31m, X||a*, Y||b, Z||c*
  h  1 -1 -2 -1  1  2
  k  1 -1  1  2 -2 -1
  i -2  2  1 -1  1 -1
  l  0  0  0  0  0  0
</pre><p>The command <a href="vector3d.eq.html">eq or ==</a> can be used to check whether two crystal directions are symmetrically equivalent. Compare</p><pre class="codeinput">Miller(1,1,-2,0,cs) == Miller(-1,-1,2,0,cs)
</pre><pre class="codeoutput">ans =
  logical
   1
</pre><p>and</p><pre class="codeinput">eq(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs),<span class="string">'antipodal'</span>)
</pre><pre class="codeoutput">ans =
  logical
   1
</pre><h2 id="9">SUB: Angle between directions</h2><p>The angle between two crystal directions m1 and m2 is defined as the smallest angle between m1 and all symmetrically equivalent directions to m2. This angle in radians is calculated by the function <a href="vector3d.angle.html">angle</a></p><pre class="codeinput">angle(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs)) / degree
</pre><pre class="codeoutput">ans =
     0
</pre><p>As always the keyword <a href="AxialDirectional.html">antipodal</a> adds antipodal symmetry to this computation</p><pre class="codeinput">angle(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs),<span class="string">'antipodal'</span>) / degree
</pre><pre class="codeoutput">ans =
     0
</pre><h2 id="11">SUB: Conversions</h2><p>Converting Miller indices into a three-dimensional vector is straight forward using the command <a href="Miller.vector3d.html">vectord3d</a>.</p><pre class="codeinput">vector3d(m)
</pre><pre class="codeoutput"> 
ans = vector3d  
 size: 1 x 1
        x       y       z
  1.73205       1       0
</pre><p>Conversion into spherical coordinates requires the function <a href="vector3d.polar.html">polar</a></p><pre class="codeinput">[theta,rho] = polar(m)
</pre><pre class="codeoutput">theta =
    1.5708
rho =
    0.5236
</pre><h2 id="13">SUB: Calculations</h2><p>Given a crystal orientation</p><pre class="codeinput">o = orientation.byEuler(20*degree,30*degree,40*degree,cs)
</pre><pre class="codeoutput"> 
o = orientation  
  size: 1 x 1
  crystal symmetry : -31m, X||a*, Y||b, Z||c*
  specimen symmetry: 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    20   30   40    0
 
</pre><p>one can apply it to a crystal direction to find its coordinates with respect to the specimen coordinate system</p><pre class="codeinput">o * m
</pre><pre class="codeoutput"> 
ans = vector3d  
 size: 1 x 1
          x         y         z
  0.0861172   1.76339  0.939693
</pre><p>In order to obtain the coordinates with respect to the specimen coordinate system of all crystallographically equivalent specimen directions we use the command <a href="Miller.symmetrise.html">symmetrise</a></p><pre class="codeinput">p = o * symmetrise(m);
plot(p)
</pre>
  {% include inline_image.html file="Miller_index_03.png" %}
<h2 id="16">Complete Function list</h2><p><table width="90%"><tr><td width="200px"><a href="Miller..html"><tt/></a></td><td/></tr><tr><td width="200px"><a href="Miller.  Syntax.html"><tt>  Syntax</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller(h,k,l,cs).html"><tt>    m = Miller(h,k,l,cs)</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller(h,k,l,cs,'hkl').html"><tt>    m = Miller(h,k,l,cs,'hkl')</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller(h,k,l,cs,'pole').html"><tt>    m = Miller(h,k,l,cs,'pole')</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller(h,k,i,l,cs).html"><tt>    m = Miller(h,k,i,l,cs)</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller('(hkl)',cs).html"><tt>    m = Miller('(hkl)',cs)</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller(u,v,w,cs,'uvw').html"><tt>    m = Miller(u,v,w,cs,'uvw')</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller(u,v,t,w,cs,'uvw').html"><tt>    m = Miller(u,v,t,w,cs,'uvw')</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller(u,v,w,cs,'direction').html"><tt>    m = Miller(u,v,w,cs,'direction')</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller('[uvw]',cs).html"><tt>    m = Miller('[uvw]',cs)</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller('[uvw]\[uvw],cs).html"><tt>    m = Miller('[uvw]\[uvw],cs)</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller('(hkl)\(hkl),cs).html"><tt>    m = Miller('(hkl)\(hkl),cs)</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.    m = Miller(x,cs) % transform vector3d to Miller.html"><tt>    m = Miller(x,cs) % transform vector3d to Miller</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller..html"><tt/></a></td><td/></tr><tr><td width="200px"><a href="Miller.  Input.html"><tt>  Input</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.   h,k,l,i.html"><tt>   h,k,l,i</tt></a></td><td>Miller indice of the plane normal</td></tr><tr><td width="200px"><a href="Miller.   u,v,w,t.html"><tt>   u,v,w,t</tt></a></td><td>Miller indice of a direction</td></tr><tr><td width="200px"><a href="Miller.   x.html"><tt>   x</tt></a></td><td>@vector3d</td></tr><tr><td width="200px"><a href="Miller.   cs.html"><tt>   cs</tt></a></td><td>crystal @symmetry</td></tr><tr><td width="200px"><a href="Miller..html"><tt/></a></td><td/></tr><tr><td width="200px"><a href="Miller.  See also.html"><tt>  See also</tt></a></td><td/></tr><tr><td width="200px"><a href="Miller.  vector3d_index symmetry_index.html"><tt>  vector3d_index symmetry_index</tt></a></td><td/></tr></table></p></div></body></html>