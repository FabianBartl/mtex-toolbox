---
title: Twinning Analysis
last_updated: 30-Sep-2019
sidebar: documentation_sidebar
permalink: TwinningBoundaries.html
folder: documentation
toc: false
---

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Twinning Analysis</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-09-30"><meta name="DC.source" content="script_TwinningBoundaries.m"></head><body><font size="2"><a href="#" data-toggle="tooltip" data-original-title="To edit this page type edit TwinningBoundaries into the Matlab commandline">edit page</a></font><div><!--introduction--><!--/introduction--><p>In this section we consider the analysis of twining. Therefore lets start by importing some Magnesium data and reconstructing the grain structure.</p><pre class="codeinput"><span class="comment">% load some example data</span>
mtexdata <span class="string">twins</span>

<span class="comment">% segment grains</span>
[grains,ebsd.grainId,ebsd.mis2mean] = calcGrains(ebsd(<span class="string">'indexed'</span>),<span class="string">'angle'</span>,5*degree);

<span class="comment">% remove two pixel grains</span>
ebsd(grains(grains.grainSize&lt;=2)) = [];
[grains,ebsd.grainId,ebsd.mis2mean] = calcGrains(ebsd(<span class="string">'indexed'</span>),<span class="string">'angle'</span>,5*degree);

<span class="comment">% smooth them</span>
grains = grains.smooth(5);

<span class="comment">% visualize the grains</span>
plot(grains,grains.meanOrientation)

<span class="comment">% store crystal symmetry of Magnesium</span>
CS = grains.CS;
</pre><pre class="codeoutput">  I'm going to colorize the orientation data with the 
  standard MTEX colorkey. To view the colorkey do:
 
  colorKey = ipfColorKey(ori_variable_name)
  plot(colorKey)
</pre>
  {% include inline_image.html file="TwinningBoundaries_01.png" %}
<p>Now we can extract from the grains its boundary and save it to a separate variable</p><pre class="codeinput">gB = grains.boundary
</pre><pre class="codeoutput"> 
gB = grainBoundary  
 
 Segments   mineral 1  mineral 2
      600  notIndexed  Magnesium
     3164   Magnesium  Magnesium
</pre><p>The output tells us that we have 3219 Magnesium to Magnesium boundary segments and 606 boundary segements where the grains are cut by the scanning boundary. To restrict the grain boundaries to a specific phase transistion you shall do</p><pre class="codeinput">gB_MgMg = gB(<span class="string">'Magnesium'</span>,<span class="string">'Magnesium'</span>)
</pre><pre class="codeoutput"> 
gB_MgMg = grainBoundary  
 
 Segments  mineral 1  mineral 2
     3164  Magnesium  Magnesium
</pre><h2 id="4">Properties of grain boundaries</h2><p>A variable of type grain boundary contains the following properties</p><div><ul><li>misorientation</li><li>direction</li><li>segLength</li></ul></div><p>These can be used to colorize the grain boundaries. By the following command, we plot the grain boundaries colorized by the misorientation angle</p><pre class="codeinput">plot(gB_MgMg,gB_MgMg.misorientation.angle./degree,<span class="string">'linewidth'</span>,2)
mtexColorbar
</pre>
  {% include inline_image.html file="TwinningBoundaries_02.png" %}
<p>We observe that we have many grain boundaries with misorientation angle larger than 80 degree. In order to investigate the distribution of misorientation angles further we have the look at a misorientation angle histogramm.</p><pre class="codeinput">histogram(gB_MgMg.misorientation.angle./degree,40)
xlabel(<span class="string">'misorientation angle (degree)'</span>)
</pre>
  {% include inline_image.html file="TwinningBoundaries_03.png" %}
<p>Lets analyze the misorientations corresponding to the peak around 86 degree in more detail. Therefore, we consider only those misorientations with misorientation angle between 85 and 87 degree</p><pre class="codeinput">ind = gB_MgMg.misorientation.angle&gt;85*degree &amp; gB_MgMg.misorientation.angle&lt;87*degree;
mori = gB_MgMg.misorientation(ind);
</pre><p>and observe that when plotted in axis angle domain they form a strong cluster close to one of the corners of the domain.</p><pre class="codeinput">scatter(mori)
</pre>
  {% include inline_image.html file="TwinningBoundaries_04.png" %}
<p>We may determin the center of the cluster and check whether it is close to some special orientation relation ship</p><pre class="codeinput"><span class="comment">% determine the mean of the cluster</span>
mori_mean = mean(mori,<span class="string">'robust'</span>)

<span class="comment">% determine the closest special orientation relation ship</span>
round2Miller(mori_mean)
</pre><pre class="codeoutput"> 
mori_mean = misorientation  
  size: 1 x 1
  crystal symmetry : Magnesium (6/mmm, X||a*, Y||b, Z||c*)
  crystal symmetry : Magnesium (6/mmm, X||a*, Y||b, Z||c*)
  antipodal:         true
 
  Bunge Euler angles in degree
     phi1     Phi    phi2    Inv.
  150.217 86.1004 210.319       0
 
 
(01-1-2) || (0-11-2)   [2-1-10] || [2-1-10]   error: 0.47&deg;
 
</pre><p>Bases on the output above we may now define the special orientation relationship as</p><pre class="codeinput">twinning = orientation.map(Miller(0,1,-1,-2,CS),Miller(0,-1,1,-2,CS),<span class="keyword">...</span>
  Miller(2,-1,-1,0,CS),Miller(2,-1,-1,0,CS))
</pre><pre class="codeoutput"> 
twinning = misorientation  
  size: 1 x 1
  crystal symmetry : Magnesium (6/mmm, X||a*, Y||b, Z||c*)
  crystal symmetry : Magnesium (6/mmm, X||a*, Y||b, Z||c*)
 
  Bunge Euler angles in degree
  phi1     Phi    phi2    Inv.
   150 86.3471     210       0
 
</pre><p>and observe that it is actually a rotation about axis (-1210) and angle 86.3 degree</p><pre class="codeinput"><span class="comment">% the rotational axis</span>
round(twinning.axis)

<span class="comment">% the rotational angle</span>
twinning.angle / degree
</pre><pre class="codeoutput"> 
ans = Miller  
 size: 1 x 1
 mineral: Magnesium (622, X||a*, Y||b, Z||c*)
  h -1
  k  2
  i -1
  l  0
ans =
   86.3471
</pre><p>Next, we check for each boundary segment whether it is a twinning boundary, i.e., whether boundary misorientation is close to the twinning.</p><pre class="codeinput"><span class="comment">% restrict to twinnings with threshold 5 degree</span>
isTwinning = angle(gB_MgMg.misorientation,twinning) &lt; 5*degree;
twinBoundary = gB_MgMg(isTwinning)

<span class="comment">% plot the twinning boundaries</span>
plot(grains,grains.meanOrientation)
<span class="comment">%plot(ebsd('indexed'),ebsd('indexed').orientations)</span>
hold <span class="string">on</span>
<span class="comment">%plot(gB_MgMg,angle(gB_MgMg.misorientation,twinning),'linewidth',4)</span>
plot(twinBoundary,<span class="string">'linecolor'</span>,<span class="string">'w'</span>,<span class="string">'linewidth'</span>,2,<span class="string">'displayName'</span>,<span class="string">'twin boundary'</span>)
hold <span class="string">off</span>
</pre><pre class="codeoutput"> 
twinBoundary = grainBoundary  
 
 Segments  mineral 1  mineral 2
     1649  Magnesium  Magnesium
  I'm going to colorize the orientation data with the 
  standard MTEX colorkey. To view the colorkey do:
 
  colorKey = ipfColorKey(ori_variable_name)
  plot(colorKey)
</pre>
  {% include inline_image.html file="TwinningBoundaries_05.png" %}
<h2 id="12">Merge twins along twin boundaries</h2><p>Grains that have a common twin boundary are assumed to inherite from one common grain. To reconstruct those initial grains we merge grains together which have a common twin boundary. This is done by the command <a href="grain2d.merge.html">merge</a>.</p><pre class="codeinput">[mergedGrains,parentId] = merge(grains,twinBoundary);

<span class="comment">% plot the merged grains</span>
<span class="comment">%plot(ebsd,ebsd.orientations)</span>
hold <span class="string">on</span>
plot(mergedGrains.boundary,<span class="string">'linecolor'</span>,<span class="string">'k'</span>,<span class="string">'linewidth'</span>,2.5,<span class="string">'linestyle'</span>,<span class="string">'-'</span>,<span class="keyword">...</span>
  <span class="string">'displayName'</span>,<span class="string">'merged grains'</span>)
hold <span class="string">off</span>
</pre>
  {% include inline_image.html file="TwinningBoundaries_06.png" %}
<h2 id="13">Grain relationships</h2><p>The second output argument <tt>paraentId</tt> of <a href="grain2d.merge.html">merge</a> is a list with the same size as grains which indicates for each grain into which common grain it has been merged. The id of the common grain is usually different from the ids of the merged grains and can be found by</p><pre class="codeinput">mergedGrains(16).id
</pre><pre class="codeoutput">ans =
    16
</pre><p>Hence, we can find all childs of grain 16 by</p><pre class="codeinput">childs = grains(parentId == mergedGrains(16).id)
</pre><pre class="codeoutput"> 
childs = grain2d  
 
 Phase  Grains  Pixels    Mineral  Symmetry  Crystal reference frame
     1       8    1698  Magnesium     6/mmm       X||a*, Y||b, Z||c*
 
 boundary segments: 442
 triple points: 25
 
 Id   Phase   Pixels          GOS   phi1   Phi   phi2
  6       1       40   0.00752395    178    90    236
 14       1      254    0.0113434     81    25    187
 17       1        4    0.0135723     80    26    189
 19       1       38   0.00595743     95   145    186
 24       1      774    0.0102947    178    90    235
 28       1       45    0.0107243     81    26    188
 29       1      293   0.00910428     94   146    185
 33       1      250    0.0106861    179    89    235
 
</pre><h2 id="15">Calculate the twinned area</h2><p>We can also answer the question about the relative area of these initial grains that have undergone twinning to total area.</p><pre class="codeinput">twinId = unique(gB_MgMg(isTwinning).grainId);

<span class="comment">% compute the area fraction</span>
sum(area(grains(twinId))) / sum(area(grains)) * 100
</pre><pre class="codeoutput">ans =
   73.5716
</pre><p>The <tt>parentId</tt> may also used to compute properties of the parent grains by averaging over the corresponding child grain properties.</p><pre class="codeinput">mergedGrains.prop.GOS = accumarray(parentId,grains.GOS,size(mergedGrains),@nanmean)

figure(1)
plot(grains,grains.GOS ./ degree)
hold <span class="string">on</span>
plot(mergedGrains.boundary,<span class="string">'lineColor'</span>,<span class="string">'white'</span>,<span class="string">'lineWidth'</span>,2)
mtexColorbar

figure(2)
plot(mergedGrains,mergedGrains.GOS  ./ degree)
mtexColorbar
caxis([0,1.5])
</pre><pre class="codeoutput"> 
mergedGrains = grain2d  
 
 Phase  Grains  Pixels    Mineral  Symmetry  Crystal reference frame
     1      28   22794  Magnesium     6/mmm       X||a*, Y||b, Z||c*
 
 boundary segments: 2099
 triple points: 34
 
 Properties: GOS
 
</pre>
  {% include inline_image.html file="TwinningBoundaries_07.png" %}

  {% include inline_image.html file="TwinningBoundaries_08.png" %}
<p>The above result is a bit unrealistic since the averages are computed between the childs ignoring their relative areas. A better approach is to compute a weighted average by the following lines.</p><pre class="codeinput"><span class="comment">% extract GOS and area</span>
childGOS = grains.GOS;
childArea = grains.area;

<span class="comment">% compute the weighted averages</span>
mergedGrains.prop.GOS = accumarray(parentId,1:length(grains),size(mergedGrains),<span class="keyword">...</span>
  @(id) nanmeanWeights(childGOS(id),childArea(id)));

figure(3)
plot(mergedGrains,mergedGrains.GOS  ./ degree)
mtexColorbar
caxis([0,1.5])
</pre>
  {% include inline_image.html file="TwinningBoundaries_09.png" %}
<h2 id="18">Setting Up the EBSD Data for the Merged Grains</h2><p>Note that the Id's of the merged grains does not fit the grainIds stored in the initial ebsd variable. As a consequence, the following command will not give the right result</p><pre class="codeinput">close <span class="string">all</span>
plot(mergedGrains(16).boundary,<span class="string">'linewidth'</span>,2)
hold <span class="string">on</span>
plot(ebsd(mergedGrains(16)),ebsd(mergedGrains(16)).orientations)
hold <span class="string">off</span>
</pre>
  {% include inline_image.html file="TwinningBoundaries_10.png" %}
<p>In order to update the grainId in the ebsd variable to the merged grains, we proceed as follows.</p><pre class="codeinput"><span class="comment">% copy ebsd data into a new variable to not change the old data</span>
ebsd_merged = ebsd;

<span class="comment">% update the grainIds to the parentIds</span>
ebsd_merged(<span class="string">'indexed'</span>).grainId = parentId(ebsd(<span class="string">'indexed'</span>).grainId)
</pre><pre class="codeoutput"> 
ebsd_merged = EBSD  
 
 Phase  Orientations     Mineral         Color  Symmetry  Crystal reference frame
     0     46 (0.2%)  notIndexed                                                 
     1  22794 (100%)   Magnesium  LightSkyBlue     6/mmm       X||a*, Y||b, Z||c*
 
 Properties: bands, bc, bs, error, mad, x, y, grainId, mis2mean
 Scan unit : um
 
</pre><p>Now the variable <tt>ebsd_merged</tt> can be indexed by the merged grains, i.e.</p><pre class="codeinput">plot(ebsd_merged(mergedGrains(16)),ebsd_merged(mergedGrains(16)).orientations)
hold <span class="string">on</span>
plot(mergedGrains(16).boundary,<span class="string">'linewidth'</span>,2)
hold <span class="string">off</span>
</pre>
  {% include inline_image.html file="TwinningBoundaries_11.png" %}
</div></body></html>