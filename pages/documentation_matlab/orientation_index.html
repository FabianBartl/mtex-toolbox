---
title: Crystal Orientations
last_updated: 11-Oct-2019
sidebar: documentation_sidebar
permalink: orientation_index.html
folder: documentation
toc: false
---

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Crystal Orientations</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-10-11"><meta name="DC.source" content="script_orientation_index.m"></head><body><font size="2"><a href="#" data-toggle="tooltip" data-original-title="To edit this page type edit orientation_index into the Matlab commandline">edit page</a></font><div><!--introduction--><p>This sections describes the class <b>orientation</b> and gives an overview how to work with crystal orientation in MTEX.</p><!--/introduction--><h2 id="2">Class Description</h2><p>In texture analysis crystal orientations are used to describe the alignment of the crystals within the specimen. A crystal orientation is defined as the rotation that maps the specimen coordinate system onto the crystal coordinate system. Since the crystal coordinate system and the specimen coordinate system are well defined only up to crystal symmetry and specimen symmetry, an orientation is in general represented by a class of crystallographically equivalent rotations. In MTEX the class <b>orientation</b> is an inheritance of the class <a href="rotation_index.html">rotation</a>. In particular, every function that is defined for a rotation is also available for an orientation.</p><h2 id="3">SUB: Defining a Crystal Orientation</h2><p>In order to define a crystal orientation one has to define crystal and specimen symmetry first.</p>
{% highlight matlab %}
cs = crystalSymmetry('cubic');
ss = specimenSymmetry('orthorhombic');
{% endhighlight %}
<p>Now a crystal orientation to a certain <a href="rotation_index.html">rotation</a></p>
{% highlight matlab %}
rot = rotation.byEuler(30*degree,50*degree,10*degree);
{% endhighlight %}
<p>is defined by</p>
{% highlight matlab %}
o = orientation(rot,cs,ss)
{% endhighlight %}

{% highlight plaintext %}
 
o = orientation  
  size: 1 x 1
  crystal symmetry : m-3m
  specimen symmetry: mmm
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    30   50   10    0
 

{% endhighlight %}
<p>In order to streamline the definition the arguments to define the rotation can be directly pass to define a orientation:</p>
{% highlight matlab %}
o = orientation.byEuler(30*degree,50*degree,10*degree,cs,ss)
{% endhighlight %}

{% highlight plaintext %}
 
o = orientation  
  size: 1 x 1
  crystal symmetry : m-3m
  specimen symmetry: mmm
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    30   50   10    0
 

{% endhighlight %}
<p>Accordingly parameterisations of rotations are also available for orientations</p><div><ul><li>Bunge Euler Angle Convention</li><li>Matthies Euler Angle Convention</li><li>Axis angle parametrisation</li><li>Fibre of orientations</li><li>Four vectors defining a rotation</li><li>3 times 3 matrix</li><li>quaternion</li></ul></div><p>Have a look at <a href="rotation_index.html">rotation help page</a> for more details. Besides these parameterisations for rotations there are also some parameterisations which are unique for orientations</p><p><b>Miller indices</b></p><p>There is also a Miller indices convention for defining crystal orientations.</p>
{% highlight matlab %}
o = orientation.byMiller([1 0 0],[0 1 1],cs,ss)
{% endhighlight %}

{% highlight plaintext %}
 
o = orientation  
  size: 1 x 1
  crystal symmetry : m-3m
  specimen symmetry: mmm
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
   135   90   90    0
 

{% endhighlight %}
<p><b>Predifined Orientations</b></p><p>In the MTEX there is a list of predefined orientations:</p><div><ul><li><a href="orientation.cube.html">cube</a></li><li><a href="orientation.goss.html">goss</a></li><li><a href="orientation.brass.html">brass</a></li></ul></div>
{% highlight matlab %}
o = orientation.goss(cs,ss)
{% endhighlight %}

{% highlight plaintext %}
 
o = orientation  
  size: 1 x 1
  crystal symmetry : m-3m
  specimen symmetry: mmm
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0   45    0    0
 

{% endhighlight %}
<h2 id="9">SUB: Rotating Crystal Directions onto Specimen Directions</h2><p>Let</p>
{% highlight matlab %}
h = Miller(1,0,0,cs)
{% endhighlight %}

{% highlight plaintext %}
 
h = Miller  
 size: 1 x 1
 symmetry: m-3m
  h 1
  k 0
  l 0

{% endhighlight %}
<p>be a certain crystal direction and</p>
{% highlight matlab %}
o = orientation.byEuler(90*degree,90*degree,0*degree,cs,ss)
{% endhighlight %}

{% highlight plaintext %}
 
o = orientation  
  size: 1 x 1
  crystal symmetry : m-3m
  specimen symmetry: mmm
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    90   90    0    0
 

{% endhighlight %}
<p>a crystal orientation. Then the alignment of this crystal direction with respect to the specimen coordinate system can be computed via</p>
{% highlight matlab %}
r = o * h
{% endhighlight %}

{% highlight plaintext %}
 
r = vector3d  
 size: 1 x 1
  x y z
  0 1 0

{% endhighlight %}
<p>Conversely the crystal direction that is mapped onto a certain specimen direction can be computed via the <a href="orientation.mldivide.html">backslash operator</a></p>
{% highlight matlab %}
o \ r
{% endhighlight %}

{% highlight plaintext %}
 
ans = Miller  
 size: 1 x 1
 symmetry: m-3m
  h 1
  k 0
  l 0

{% endhighlight %}
<h2 id="13">SUB: Concatenating Rotations</h2><p>Let</p>
{% highlight matlab %}
o = orientation.byEuler(90*degree,0,0,cs,ss);
rot = rotation.byEuler(0,60*degree,0);
{% endhighlight %}
<p>be a crystal orientation and a rotation of the specimen coordinate system. Then the orientation of the crystal with respect to the rotated specimen coordinate system calculates by</p>
{% highlight matlab %}
o1 = rot * o
{% endhighlight %}

{% highlight plaintext %}
 
o1 = orientation  
  size: 1 x 1
  crystal symmetry : m-3m
  specimen symmetry: 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0   60   90    0
 

{% endhighlight %}
<p>Then the class of rotations crystallographically equivalent to o can be computed in two ways. Either by using the command <a href="orientation.symmetrise.html">symmetrise</a></p>
{% highlight matlab %}
symmetrise(o)
{% endhighlight %}

{% highlight plaintext %}
 
ans = orientation  
  size: 384 x 1
  crystal symmetry : m-3m
  specimen symmetry: mmm
 

{% endhighlight %}
<p>or by using multiplication</p>
{% highlight matlab %}
ss * o * cs
{% endhighlight %}

{% highlight plaintext %}
 
ans = orientation  
  size: 8 x 48
  crystal symmetry : m-3m
  specimen symmetry: mmm
 

{% endhighlight %}
<h2 id="17">SUB: Calculating Misorientations</h2><p>Let cs and ss be crystal and specimen symmetry and o1 and o2 two crystal orientations. Then one can ask for the misorientation between both orientations. This misorientation can be calculated by the function <a href="orientation.angle.html">angle</a>.</p>
{% highlight matlab %}
angle(rot * o1,o1) / degree
{% endhighlight %}

{% highlight plaintext %}
ans =
   30.0000

{% endhighlight %}
<p>This misorientation angle is, in general, smaller than the misorientation without crystal symmetry which can be computed via</p>
{% highlight matlab %}
angle(rotation(o),rotation(o1)) /degree
{% endhighlight %}

{% highlight plaintext %}
ans =
   60.0000

{% endhighlight %}
<h2 id="19">SUB: Calculating with Orientations and Rotations</h2><p>Besides the standard linear algebra operations there are also the following functions available in MTEX. Then rotational angle and the axis of rotation can be computed via then commands <a href="quaternion.angle.html">angle(o)</a> and <a href="quaternion.axis.html">axis(o)</a></p>
{% highlight matlab %}
angle(o1)/degree

axis(o1)
{% endhighlight %}

{% highlight plaintext %}
ans =
   30.0000
 
ans = Miller  
 size: 1 x 1
 symmetry: 1, X||a, Y||b*, Z||c*
  h -1
  k  0
  l  0

{% endhighlight %}
<p>The inverse orientation to o you get from the command <a href="quaternion.inv.html">inv(q)</a></p>
{% highlight matlab %}
inv(o1)
{% endhighlight %}

{% highlight plaintext %}
 
ans = inverse orientation  
  size: 1 x 1
  specimen symmetry: 1
  crystal symmetry : m-3m
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    90   60  180    0
 

{% endhighlight %}
<h2 id="21">SUB: Conversion into Euler Angles and Rodrigues Parametrisation</h2><p>There are methods to transform quaternion in almost any other parameterization of rotations as they are:</p><div><ul><li><a href="quaternion.Euler.html">Euler(o)</a>   in Euler angle</li><li><a href="quaternion.Rodrigues.html">Rodrigues(o)</a> % in Rodrigues parameter</li></ul></div>
{% highlight matlab %}
[phi1,Phi,phi2] = Euler(o)
{% endhighlight %}

{% highlight plaintext %}
phi1 =
    1.5708
Phi =
     0
phi2 =
     0

{% endhighlight %}
<h2 id="22">SUB: Plotting Orientations</h2><p>The <a href="orientation.plot.html">plot</a> function allows you to visualize an orientation in axis angle space in relation to its fundamental region.</p>
{% highlight matlab %}
oR = fundamentalRegion(o1.CS,o1.SS)
plot(oR)
hold on
% plot the orientation as it is
plot(o1,'markercolor','b','markerSize',10)

% plot the orientation within the fundamental zone
plot(o1.project2FundamentalRegion,'markercolor','r','markerSize',10)
hold off
{% endhighlight %}

{% highlight plaintext %}
 
oR = orientationRegion  
 
 crystal symmetry:  432
 max angle: 62.7994&deg;
 face normales: 14
 vertices: 24
 

{% endhighlight %}

  {% include inline_image.html file="orientation_index_01.png" %}
<h2 id="23">Complete Function list</h2><p><table width="90%"><tr><td width="200px"><a href="orientation..html"><tt/></a></td><td/></tr><tr><td width="200px"><a href="orientation.  This MTEX class represents orientations and misorientations..html"><tt>  This MTEX class represents orientations and misorientations.</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation..html"><tt/></a></td><td/></tr><tr><td width="200px"><a href="orientation.  Syntax.html"><tt>  Syntax</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.    ori = orientation(rot).html"><tt>    ori = orientation(rot)</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.    ori = orientation.byEuler(phi1,Phi,phi2,cs,ss).html"><tt>    ori = orientation.byEuler(phi1,Phi,phi2,cs,ss)</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.    ori = orientation.byEuler(alpha,beta,gamma,'ZYZ',cs,ss).html"><tt>    ori = orientation.byEuler(alpha,beta,gamma,'ZYZ',cs,ss)</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.    ori = orientation.byMiller([h k l],[u v w],cs,ss).html"><tt>    ori = orientation.byMiller([h k l],[u v w],cs,ss)</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.    ori = orientation.byAxisAngle(v,omega,cs,ss).html"><tt>    ori = orientation.byAxisAngle(v,omega,cs,ss)</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.    ori = orientation.byMatrix(A,cs).html"><tt>    ori = orientation.byMatrix(A,cs)</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.    ori = orientation.map(u1,v1,u2,v2,cs).html"><tt>    ori = orientation.map(u1,v1,u2,v2,cs)</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.    ori = orientation.goss(cs).html"><tt>    ori = orientation.goss(cs)</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.    ori = orientation.cube(cs).html"><tt>    ori = orientation.cube(cs)</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation..html"><tt/></a></td><td/></tr><tr><td width="200px"><a href="orientation.  Input.html"><tt>  Input</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.   rot.html"><tt>   rot</tt></a></td><td>@rotation</td></tr><tr><td width="200px"><a href="orientation.   cs, ss.html"><tt>   cs, ss</tt></a></td><td>@crystalSymmetry / @specimenSymmetry</td></tr><tr><td width="200px"><a href="orientation..html"><tt/></a></td><td/></tr><tr><td width="200px"><a href="orientation.  Output.html"><tt>  Output</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.   ori.html"><tt>   ori</tt></a></td><td>@orientation</td></tr><tr><td width="200px"><a href="orientation..html"><tt/></a></td><td/></tr><tr><td width="200px"><a href="orientation.  Class Properties.html"><tt>  Class Properties</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.   CS, SS.html"><tt>   CS, SS</tt></a></td><td>@crystalSymmetry / @specimenSymmetry</td></tr><tr><td width="200px"><a href="orientation.   antipodal.html"><tt>   antipodal</tt></a></td><td>grain exchange symmetry for misorientations</td></tr><tr><td width="200px"><a href="orientation.   phi1, Phi, phi2.html"><tt>   phi1, Phi, phi2</tt></a></td><td>Euler angles</td></tr><tr><td width="200px"><a href="orientation.   i.html"><tt>   i</tt></a></td><td>inversion</td></tr><tr><td width="200px"><a href="orientation.   a, b, c, d.html"><tt>   a, b, c, d</tt></a></td><td>quaternion components</td></tr><tr><td width="200px"><a href="orientation..html"><tt/></a></td><td/></tr><tr><td width="200px"><a href="orientation.  See also.html"><tt>  See also</tt></a></td><td/></tr><tr><td width="200px"><a href="orientation.  DefinitionAsCoordinateTransform CrystalOperations CrystalReferenceSystem.html"><tt>  DefinitionAsCoordinateTransform CrystalOperations CrystalReferenceSystem</tt></a></td><td/></tr></table></p></div></body></html>