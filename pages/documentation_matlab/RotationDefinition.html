---
title: Defining Rotations
last_updated: 05-Oct-2019
sidebar: documentation_sidebar
permalink: RotationDefinition.html
folder: documentation
toc: false
---

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Defining Rotations</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-10-05"><meta name="DC.source" content="script_RotationDefinition.m"></head><body><font size="2"><a href="#" data-toggle="tooltip" data-original-title="To edit this page type edit RotationDefinition into the Matlab commandline">edit page</a></font><div><!--introduction--><p>Rotations are the basic concept to understand crystal orientations and crystal symmetries.</p><!--/introduction--><p>Rotations are represented in MTEX by the class <b>[[rotation_index.html,rotation]]</b> which is inherited from the class <a href="quaternion_index.html">quaternion</a> and allow to</p><h2 id="2">Euler Angles</h2><p>There are several ways to specify a rotation in MTEX. A well known possibility are the so called <b>Euler angles</b>. In texture analysis the following conventions are commonly used</p><div><ul><li>Bunge (phi1,Phi,phi2)       - ZXZ</li><li>Matthies (alpha,beta,gamma) - ZYZ</li><li>Roe (Psi,Theta,Phi)</li><li>Kocks (Psi,Theta,phi)</li><li>Canova (omega,Theta,phi)</li></ul></div><p><b>Defining a Rotation by Bunge Euler Angles</b></p><p>The default Euler angle convention in MTEX are the Bunge Euler angles. Here a rotation is determined by three consecutive rotations, the first about the z-axis, the second about the y-axis, and the third again about the z-axis. Hence, one needs three angles to define an rotation by Euler angles. The following command defines a rotation by its three Bunge Euler angles</p><pre class="codeinput">rot = rotation.byEuler(30*degree,50*degree,10*degree)
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    30   50   10    0
 
</pre><p><b>Defining a Rotation by Other Euler Angle Conventions</b></p><p>In order to define a rotation by a Euler angle convention different to the default Euler angle convention you to specify the convention as an additional parameter, e.g.</p><pre class="codeinput">rot = rotation.byEuler(30*degree,50*degree,10*degree,<span class="string">'Roe'</span>)
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
   120   50  280    0
 
</pre><p><b>Changing the Default Euler Angle Convention</b></p><p>The default Euler angle convention can be changed by the command <b>setpref</b>, for a permanent change the <a href="matlab:edit('mtex_settings.m')">mtex_settings</a> should be edited. Compare</p><pre class="codeinput">setMTEXpref(<span class="string">'EulerAngleConvention'</span>,<span class="string">'Roe'</span>)
rot
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1 x 1
 
  Roe Euler angles in degree
  Psi Theta   Phi  Inv.
   30    50    10     0
 
</pre><pre class="codeinput">setMTEXpref(<span class="string">'EulerAngleConvention'</span>,<span class="string">'Bunge'</span>)
rot
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
   120   50  280    0
 
</pre><h2 id="6">Other Ways of Defining a Rotation</h2><p><b>The axis angle parametrisation</b></p><p>A very simple possibility to specify a rotation is to specify the rotation axis and the rotation angle.</p><pre class="codeinput">rot = rotation.byAxisAngle(xvector,30*degree)
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0   30    0    0
 
</pre><p><b>Four vectors defining a rotation</b></p><p>Given four vectors u1, v1, u2, v2 there is a unique rotation q such that q u1 = v1 and q u2 = v2.</p><pre class="codeinput">rot = rotation.map(xvector,yvector,zvector,zvector)
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    90    0    0    0
 
</pre><p>If only two vectors are specified, then the rotation with the smallest angle is returned and gives the rotation from first vector onto the second one.</p><pre class="codeinput">rot = rotation.map(xvector,yvector)
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    90    0    0    0
 
</pre><p><b>A fibre of rotations</b></p><p>The set of all rotations that rotate a certain vector u onto a certain vector v define a fibre in the rotation space. A discretisation of such a fibre is defined by</p><pre class="codeinput">u = xvector;
v = yvector;
rot = rotation(fibre(u,v))
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1000 x 1
 
</pre><p><b>Defining an rotation by a 3 times 3 matrix</b></p><pre class="codeinput">rot = rotation(<span class="string">'matrix'</span>,eye(3))
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0    0    0    0
 
</pre><p><b>Defining an rotation by a quaternion</b></p><p>A last possibility is to define a rotation by a quaternion, i.e., by its components a,b,c,d.</p><pre class="codeinput">rot = rotation(<span class="string">'quaternion'</span>,1,0,0,0)
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0    0    0    0
 
</pre><p>Actually, MTEX represents internally every rotation as a quaternion. Hence, one can write</p><pre class="codeinput">q = quaternion(1,0,0,0)
rot = rotation(q)
</pre><pre class="codeoutput"> 
q = Quaternion  
  size: 1 x 1
  a b c d
  1 0 0 0
 
rot = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0    0    0    0
 
</pre></div></body></html>