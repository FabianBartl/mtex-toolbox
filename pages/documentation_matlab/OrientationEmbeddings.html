---
title: Embeddings of Orientations
last_updated: 24-Jul-2020
sidebar: documentation_sidebar
permalink: OrientationEmbeddings.html
folder: documentation
toc: false
---
    <html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Embeddings of Orientations</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-07-24"><meta name="DC.source" content="script_OrientationEmbeddings.m"></head><body><font size="2"><a href="https://github.com/mtex-toolbox/mtex/blob/develop/doc/CrystalOrientations/OrientationEmbeddings.m">
    edit page</a></font><div><!--introduction--><!--/introduction--><p>Orientational embeddings are tensorial representations of orientations with the specific property that each class of symmetrically equivalent orientations has a unique tensor representation. The easiest tensorial representation of a rotation is its rotational matrix. However, in the presense of crystal symmetry multiple rotational matrices describe the same orientation. This can be avoided by restricting the space of admissible matrices to the so called fundamental region. However, this creates the problem that two similar orientations may be represented by very different matrices in the fundamental region. This ussualy happens if the orientations are close to the boundary of the fundamental region.</p><p>The central problem is that the geometry of the fundamental region is not the geometry of the orientation space. Lets demonstate this by taking pairs of random orientations in the fundamental region and compare their misorientation angle with the Euclidean distance of the corresponding rotational matrices and the corresponding Rodrigues Frank vectors.</p>
{% highlight matlab %}
% consider cubic symmetry
cs = crystalSymmetry('432');

% random pairs of orientations in the fundamental sector
ori1 = project2FundamentalRegion(orientation.rand(100000,cs));
ori2 = project2FundamentalRegion(orientation.rand(100000,cs));

% compute the misorienation angles in degree
omega = angle(ori1,ori2)./degree;

% compute the Euclidean distance between the rotational matrices
distMat = norm(tensor(ori1) - tensor(ori2));

% compute the Euclidean distance between the Rodrigues Frank vectors
distRV = norm(Rodrigues(ori1) - Rodrigues(ori2));

% plot
subplot(1,2,1)
scatter(omega,distMat)
xlabel('misorientation angle')
ylabel('matrix distance')

subplot(1,2,2)
scatter(omega,distRV)
xlabel('misorientation angle')
ylabel('Rodrigues distance')
{% endhighlight %}
<center>
{% include inline_image.html file="OrientationEmbeddings_01.png" %}
</center><p>We observe that orientations may be far from each other in Rodrigues Frank space but have small misorientation angle. As a consequence, we not simply compute the average of two orientation by taking the mean of the corresponding Rodrigues vectors. Lets have a look at an extremal case of finding the mean orientations of the orientations (44,0,0) and (46,0,0)</p>
{% highlight matlab %}
% define two orientations
ori = orientation.byEuler([44 46]*degree,0,0,cs);
ori = ori.project2FundamentalRegion;

%compute the mean by averagin the Rodrigues vectors
mori = orientation.byRodrigues(mean(ori.Rodrigues),cs)
{% endhighlight %}

{% highlight plaintext %}
mori = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0    0    0    0
{% endhighlight %}
<p>The  mean orientation computed from the average of the Rodrigues vectors is (0,0,0) is far away from the true mean.</p>
{% highlight matlab %}
mean(ori)
{% endhighlight %}

{% highlight plaintext %}
ans = orientation  
  size: 1 x 1
  crystal symmetry : 432
  specimen symmetry: 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    45    0    0    0
{% endhighlight %}
<p>This issue does not only apply to the mean but actually to all statistical methods that work well for vectorial data and that one would like to apply to orientation data.</p><p>The crucial idea of an embedding is to replace the vectorial representation with a higher dimensional tensorial representation that preserves the geometry and the distances of the orientation space as good as possible.</p><h2 id="5">Defining an embedding</h2><p>Defining an embedding of an orientation <code class="language-plaintext highlighter-rouge">ori</code> is done by calling the function <a href="embedding.html"><code class="language-plaintext highlighter-rouge">embedding</code></a>.</p>
{% highlight matlab %}
e1 = embedding(ori1);
e2 = embedding(ori2)
{% endhighlight %}

{% highlight plaintext %}
e2 = embedding  
 symmetry: 432
 size: 100000 x 1
{% endhighlight %}
<p>This creates a variable of type <a href="embedding.html"><code class="language-plaintext highlighter-rouge">embedding</code></a> that behaves like list of vectors, i.e., variable of type <a href="embedding.html"><code class="language-plaintext highlighter-rouge">embedding</code></a> can be summed, rotated, scaled and one can compute the inner product between two embeddings. Lets have a look at the Euclidean distances between the embeddings <code class="language-plaintext highlighter-rouge">e1</code> and <code class="language-plaintext highlighter-rouge">e2</code></p>
{% highlight matlab %}
% the Euclidean distance in the embedding
distE = norm(e1-e2) ./ degree;

close all
scatter(omega,distE)
xlabel('misorientation angle')
ylabel('embedding distance')
{% endhighlight %}
<center>
{% include inline_image.html file="OrientationEmbeddings_02.png" %}
</center><p>We observe that distance in the embedding differs slightly from the misorientation angle. However, especially for small misorientation angles the approximation is very good.</p><p>Lets go back to our second example of averaging the orientations (44,0,0) and (46,0,0). If we compute the embedding of both orientations, average the resulting tensors and then project to mean tensor back to an orientation we end up with the correct result (0,0,0).</p>
{% highlight matlab %}
% compute the embedding of the two orientations
e = embedding(ori)

% take the mean of the embeddings
me = mean(e);

% computet an orientation from the mean embedding
orientation(me)
{% endhighlight %}

{% highlight plaintext %}
e = embedding  
 symmetry: 432
 size: 2 x 1
 
ans = orientation  
  size: 1 x 1
  crystal symmetry : 432
  specimen symmetry: 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0    0    0    0
{% endhighlight %}
<h2 id="8">Basic Properties</h2><p>By construction the embeddings of all orientations have the same norm.</p>
{% highlight matlab %}
norm(embedding(orientation.rand(5,cs))).'
{% endhighlight %}

{% highlight plaintext %}
ans =
    1.0000    1.0000    1.0000    1.0000    1.0000
{% endhighlight %}
<p>In other words the embeddings a located on the surface of a ball with a specific radius. When computing the mean from a list of embeddings the resulting tensor has in general a smaller norm, i.e., is inside this ball. Similarly as in spherical statistics the norm of the mean of the embeddings can be interpreted as a measure of the dispersion of the orientations. If the norm is close to 1 the orientations are tightly concentrated around a prefered orientation, whereas if the norm is close to zero some of the orientations are at maximum distance to each other.</p><p>Lets demonstrate this with a simple example</p>
{% highlight matlab %}
% genrate samples of orientations of different dispersion
n = []; sigma = [];
for hw = logspace(-1,1.75,40)*degree

  psi = deLaValleePoussinKernel('halfwidth',hw);
  odf = unimodalODF(orientation.rand(cs),psi);
  ori = discreteSample(odf,round(1000*(hw*6)^3));

  n(end+1) = norm(mean(embedding(ori)));

  sigma(end+1) = std(ori);
  progress(length(sigma),40);

end

plot(sigma,real(sqrt(1-n)),'linewidth',2)
xlabel('dispersion')
ylabel('norm of the mean')
{% endhighlight %}
<center>
{% include inline_image.html file="OrientationEmbeddings_03.png" %}
</center><p>In the previous section we have generated the orientations out of a family of random variables - unimodal de la Vallee Poussin distributed density function. A broader family of density function are the Bingham distributions. Lets repeat the experiment for this family.</p>
{% highlight matlab %}
% genrate ODF of different halfwidth
n = []; sigma = [];
for k = 1:2:600

  kappa = rand(4,1);
  kappa = k * kappa ./sum(kappa);
  odf = BinghamODF(kappa,cs);
  ori = discreteSample(odf,1000);

  n(end+1) = norm(mean(embedding(ori)));

  sigma(end+1) = std(ori);

end

hold on
scatter(sigma,sqrt(1-n),'linewidth',2)
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="OrientationEmbeddings_04.png" %}
</center></div></body></html>