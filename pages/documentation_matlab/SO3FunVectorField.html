---
title: SO3VectorField

sidebar: documentation_sidebar
permalink: SO3FunVectorField.html
folder: documentation
toc: false
---
    <html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>SO3VectorField</title><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.source" content="script_SO3FunVectorField.m"></head><body><font size="2"><a href="https://github.com/mtex-toolbox/mtex/blob/develop/doc/SO3Functions/SO3FunVectorField.m">
    edit page</a></font><div><!--introduction--><p><a href="SO3VectorField.SO3VectorField">SO3VectorField</a> handles three-dimensional functions on the rotation group. For instance the gradient of an univariate <a href="SO3FunHarmonic.SO3FunHarmonic"><code class="language-plaintext highlighter-rouge">SO3FunHarmonic</code></a> can return a <a href="SO3VectorFieldHarmonic.SO3VectorFieldHarmonic">SO3VectorFieldHarmonic</a>.</p><!--/introduction--><h2 id="1">Defining a SO3VectorFieldHandle</h2><p>Analogous to <code class="language-plaintext highlighter-rouge"><a href="SO3FunHandle.SO3FunHandle.html">SO3FunHandle</a></code> we are able to define <code class="language-plaintext highlighter-rouge">SO3VectorFields</code> by an <a href="https://de.mathworks.com/help/matlab/matlab_prog/anonymous-functions.html">anonymous function</a>.</p>
{% highlight matlab %}
f = @(rot) vector3d(rot.phi1, rot.phi2, 0*rot.phi1);

SO3VF = SO3VectorFieldHandle(f)
{% endhighlight %}

{% highlight plaintext %}
SO3VF = SO3VectorFieldHandle (xyz → xyz)
  tangent space: leftVector
{% endhighlight %}
<p>Note that the evaluations are of class <code class="language-plaintext highlighter-rouge"><a href="vector3d.vector3d.html">vector3d</a></code></p>
{% highlight matlab %}
rot = rotation.rand(2);
SO3VF.eval(rot)
{% endhighlight %}

{% highlight plaintext %}
ans = SO3TangentVector
 size: 2 x 1
 TagentSpace: leftVector
        x       y       z
  4.82102 6.21714       0
   3.4567 1.47393       0
{% endhighlight %}
<h2 id="4">Defining a SO3VectorFieldHarmonic</h2><p><b>Definition via SO3VectorField</b></p><p>We can expand any <code class="language-plaintext highlighter-rouge"><a href="SO3VectorField.SO3VectorField.html">SO3VectorField</a></code> in an <code class="language-plaintext highlighter-rouge"><a href="SO3VectorFieldHarmonic.SO3VectorFieldHarmonic.html">SO3VectorFieldHarmonic</a></code> directly by the command <code class="language-plaintext highlighter-rouge">SO3VectorFieldHarmonic</code></p>
{% highlight matlab %}
SO3VectorFieldHarmonic(SO3VF)
{% endhighlight %}

{% highlight plaintext %}
ans = SO3VectorFieldHarmonic (xyz → xyz)
  bandwidth: 64
  tangent space: leftVector
{% endhighlight %}
<p><b>Definition via function values</b></p><p>At first we need some example rotations</p>
{% highlight matlab %}
nodes = equispacedSO3Grid(specimenSymmetry('1'),'points',1e3);
nodes = nodes(:);
{% endhighlight %}
<p>Next, we define function values for the rotations</p>
{% highlight matlab %}
y = vector3d.byPolar(sin(3*nodes.angle), nodes.phi2+pi/2);
{% endhighlight %}
<p>Now the actual command to get <code class="language-plaintext highlighter-rouge">SO3VF1</code> of type <code class="language-plaintext highlighter-rouge">SO3VectorFieldHarmonic</code></p>
{% highlight matlab %}
SO3VF1 = SO3VectorFieldHarmonic.approximation(nodes, y)
{% endhighlight %}

{% highlight plaintext %}
Warning: The given vector3d values v are assumed to describe elements w.r.t.
the left side tangent space. If you want them to be right sided use
SO3TangentVector(v,'right') instead. 
 
SO3VF1 = SO3VectorFieldHarmonic (xyz → xyz)
  bandwidth: 10
  tangent space: leftVector
{% endhighlight %}
<p><b>Definition via function handle</b></p><p>If we have a function handle for the function we could create a <code class="language-plaintext highlighter-rouge">S2VectorFieldHarmonic</code> via quadrature. At first lets define a function handle which takes <a href="rotation.rotation.html"><code class="language-plaintext highlighter-rouge">rotation</code></a> as an argument and returns a <a href="vector3d.vector3d.html"><code class="language-plaintext highlighter-rouge">vector3d</code></a>:</p><p>Now we can call the quadrature command to get <code class="language-plaintext highlighter-rouge">SO3VF2</code> of type <code class="language-plaintext highlighter-rouge">SO3VectorFieldHarmonic</code></p>
{% highlight matlab %}
SO3VF2 = SO3VectorFieldHarmonic.quadrature(@(v) f(v))
{% endhighlight %}

{% highlight plaintext %}
SO3VF2 = SO3VectorFieldHarmonic (xyz → xyz)
  bandwidth: 64
  tangent space: leftVector
{% endhighlight %}
<p><b>Definition via <a href="SO3FunHarmonic.SO3FunHarmonic"><code class="language-plaintext highlighter-rouge">SO3FunHarmonic</code></a></b></p><p>If we directly call the constructor with a multivariate <a href="SO3FunHarmonic.SO3FunHarmonic"><code class="language-plaintext highlighter-rouge">SO3FunHarmonic</code></a> with three entries it will create a <code class="language-plaintext highlighter-rouge">SO3VectorFieldHarmonic</code> with <code class="language-plaintext highlighter-rouge">SO3F(1)</code>, <code class="language-plaintext highlighter-rouge">SO3F(2)</code>, and <code class="language-plaintext highlighter-rouge">SO3F(3)</code> the \(x\), \(y\), and \(z\) component.</p>
{% highlight matlab %}
SO3F = SO3FunHarmonic(rand(1e3, 3))
SO3VF3 = SO3VectorFieldHarmonic(SO3F)
{% endhighlight %}

{% highlight plaintext %}
SO3F = SO3FunHarmonic (xyz → xyz)
  isReal: false
  size: 3 x 1
  bandwidth: 9
  weight: 0.22
 
 
SO3VF3 = SO3VectorFieldHarmonic (xyz → xyz)
  isReal: false
  bandwidth: 9
  tangent space: leftVector
{% endhighlight %}
<h2 id="12">Operations</h2><p><b>Basic arithmetic operations</b></p><p>Again the basic mathematical operations are supported:</p><p>addition/subtraction of a vector field and a vector or addition/subtraction of two vector fields</p>
{% highlight matlab %}
SO3VF1 + SO3VF2; SO3VF1+vector3d(1, 0, 0);
SO3VF1-SO3VF2; SO3VF2-vector3d(sqrt(2)/2, sqrt(2)/2, 0);
{% endhighlight %}
<p>multiplication/division by a scalar or a <code class="language-plaintext highlighter-rouge">SO3Fun</code></p>
{% highlight matlab %}
2.*SO3VF1; SO3VF1./4;
SO3F = SO3FunHarmonic.example;
SO3F.SRight = specimenSymmetry;
SO3F = SO3F.symmetrise;
SO3F .* SO3VF1;
{% endhighlight %}
<p>dot product with a vector or another vector field</p>
{% highlight matlab %}
dot(SO3VF1, SO3VF2);


dot(SO3VF1, vector3d(0, 0, 1));
{% endhighlight %}
<p>cross product with a vector or another vector field</p>
{% highlight matlab %}
cross(SO3VF1, SO3VF2);

cross(SO3VF1, vector3d(0, 0, 1));
{% endhighlight %}
<p>mean vector of the vector field</p>
{% highlight matlab %}
mean(SO3VF1);
{% endhighlight %}
<p>rotation of the vector field</p>
{% highlight matlab %}
r = rotation.byEuler( [pi/4 0 0]);
rotate(SO3VF1, r);
{% endhighlight %}
<p>pointwise norm of the vectors</p>
{% highlight matlab %}
norm(SO3VF1);
{% endhighlight %}
<h2 id="21">Visualization</h2><p>One can use the default <code class="language-plaintext highlighter-rouge">plot</code>-command</p>
{% highlight matlab %}
plot(SO3VF1);
{% endhighlight %}
<center>
{% include inline_image.html file="SO3FunVectorField_01.png" %}
</center><p>or the 3D plot of the rotation group with the vectors on itself</p>
{% highlight matlab %}
clf;
quiver3(SO3VF2);
{% endhighlight %}

{% highlight plaintext %}
Warning: Setting the "WindowButtonDownFcn" property is not permitted while this
mode is active. 
Warning: Setting the "WindowButtonUpFcn" property is not permitted while this
mode is active. 
Warning: Setting the "KeyPressFcn" property is not permitted while this mode is
active. 
Warning: Setting the "WindowScrollWheelFcn" property is not permitted while
this mode is active.
{% endhighlight %}
<center>
{% include inline_image.html file="SO3FunVectorField_02.png" %}
</center></div></body></html>