---
title: Crystal Orientations
last_updated: 26-Mar-2019
sidebar: documentation_sidebar
permalink: CrystalOrientations.html
folder: documentation
toc: false
---

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Crystal Orientations</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-03-26"><meta name="DC.source" content="script_CrystalOrientations.m"></head><body><font size="2"><a href="#" data-toggle="tooltip" data-original-title="To edit this page type edit CrystalOrientations into the Matlab commandline">edit page</a></font><div><!--introduction--><p>Explains how to define crystal orientations, how to switch between different convention and how to compute crystallographic equivalent orientations.</p><!--/introduction--><h2 id="2">Contents</h2><h2 id="3">Definition</h2><p>Crystal orientations are rotations that describe the alignment of the crystal lattice with respect to a fixed specimen reference frame. Thus they consist of two incredients. A <a href="rotation_index.html">rotation</a></p><pre class="codeinput"><span class="comment">% lets take a random one</span>
rot = rotation.rand
</pre><pre class="codeoutput"> 
rot = rotation  
  size: 1 x 1
 
  Bunge Euler angles in degree
     phi1     Phi    phi2    Inv.
  145.283 29.7165 331.529       0
 
</pre><p>and a description of the crystal lattice, which are represented in MTEX by variables of type <a href="crystalSymmetry_index.html">crystalSymmetry</a></p><pre class="codeinput">cs = crystalSymmetry(<span class="string">'cubic'</span>)
</pre><pre class="codeoutput"> 
cs = crystalSymmetry  
 
  symmetry: m-3m   
  a, b, c : 1, 1, 1
 
</pre><p>Combining both incredients allows us to define an orientation</p><pre class="codeinput">ori = orientation(rot,cs)
</pre><pre class="codeoutput"> 
ori = orientation  
  size: 1 x 1
  crystal symmetry : m-3m
  specimen symmetry: 1
 
  Bunge Euler angles in degree
     phi1     Phi    phi2    Inv.
  145.283 29.7165 331.529       0
 
</pre><p>As a consequence a variable of type orientation is at the same time of type <a href="rotation_index.html">rotation</a> and hence allows for all <a href="rotation_index.html">operations</a> that are available for rotations.</p><h2 id="7">Coordinate Transformations</h2><p>In MTEX orientations are defined as the coordinate transformation that transforms coordinates of a (direction, tensor, slip system) with respect to a crystal fixed coordinate system into coordinates with respect to the specimen coordinate system.</p><p>As an example we consider the crystal direction</p><pre class="codeinput">h = Miller(1,0,0,cs,<span class="string">'uvw'</span>)
</pre><pre class="codeoutput"> 
h = Miller  
 size: 1 x 1
 symmetry: m-3m
  u 1
  v 0
  w 0
</pre><p>Then in specimen coordinates the direction <tt>h</tt> has the coordinates</p><pre class="codeinput">r = ori * h
</pre><pre class="codeoutput"> 
r = vector3d  
 size: 1 x 1
          x         y         z
  -0.486764  0.840961 -0.236315
</pre><p>Conversely, we can go back from specimen coordinates to crystal coordinates by multiplying with the inverse orientation</p><pre class="codeinput">inv(ori) * r
</pre><pre class="codeoutput"> 
ans = Miller  
 size: 1 x 1
 symmetry: m-3m
  h 1
  k 0
  l 0
</pre><p>Note, that in literature orientations are often defined to transform specimen coordinates into crystal coordinates, i.e., to coincide with the inverse orientations in MTEX. The consequences of this differences are exhaustivly discussed in the topic <a href="MTEXvsBungeConvemtion.html">orientation convemtions</a>.</p><p>In the same manner orientations can be used to transform tensors given with respect to the crystal reference system</p><pre class="codeinput">cs = crystalSymmetry(<span class="string">'mmm'</span>,[4.7646 10.2296 5.9942],<span class="string">'mineral'</span>,<span class="string">'Olivin'</span>);

fname = fullfile(mtexDataPath,<span class="string">'tensor'</span>,<span class="string">'Olivine1997PC.GPa'</span>);
C = stiffnessTensor.load(fname,cs)
</pre><pre class="codeoutput"> 
C = stiffnessTensor  
  unit   : GPa              
  rank   : 4 (3 x 3 x 3 x 3)
  mineral: Olivin (mmm)     
 
  tensor in Voigt matrix representation:
 320.5  68.2  71.6     0     0     0
  68.2 196.5  76.8     0     0     0
  71.6  76.8 233.5     0     0     0
     0     0     0    64     0     0
     0     0     0     0    77     0
     0     0     0     0     0  78.7
</pre><p>into tensors given with respect to the specimen coordinate system</p><pre class="codeinput"><span class="comment">% some random orientation</span>
ori = orientation.rand(cs)

<span class="comment">% transform into specimen coordinates</span>
ori * C
</pre><pre class="codeoutput"> 
ori = orientation  
  size: 1 x 1
  crystal symmetry : Olivin (mmm)
  specimen symmetry: 1
 
  Bunge Euler angles in degree
     phi1     Phi    phi2    Inv.
  266.306 128.197 350.304       0
 
 
ans = stiffnessTensor  
  unit: GPa              
  rank: 4 (3 x 3 x 3 x 3)
 
  tensor in Voigt matrix representation:
 214.5  70.5  81.5    -1    10  -1.8
  70.5 316.9  70.7  12.3   1.4  -3.8
  81.5  70.7 206.8     3   7.6  -0.8
    -1  12.3     3  79.2  -1.3  -1.2
    10   1.4   7.6  -1.3  69.1   1.5
  -1.8  -3.8  -0.8  -1.2   1.5  77.5
</pre><p>Objects that can be translated by orientations from crystal into specimen cooordinates and vice verca include</p><div><ul><li><a href="Miller_index.html">crystal directions</a></li><li><a href="tensor_index.html">tensors</a></li><li><a href="slipSystem_index.html">slip systems</a></li><li><a href="twinningSystem_index.html">twinning systems</a></li><li><a href="dislocationSystem_index.html">dislocation systems</a></li><li><a href="crystalShape_index.html">crystal shapes</a></li></ul></div><h2 id="13">Specimen Rotation</h2><p>Rotations of the specimen ,i.e., changing the specimen reference frame, do also change the orientation. Assume the specimen is rotated about the X-axis about 60 degree. We may define this rotation by</p><pre class="codeinput">rot = rotation.byAxisAngle(vector3d.X,60*degree);
</pre><p>Then an orientation <tt>ori</tt> is updated to the rotated reference frame by</p><pre class="codeinput">ori_new = rot * ori
</pre><pre class="codeoutput"> 
ori_new = orientation  
  size: 1 x 1
  crystal symmetry : Olivin (mmm)
  specimen symmetry: 1
 
  Bunge Euler angles in degree
    phi1     Phi    phi2    Inv.
  234.43 105.387 286.621       0
 
</pre><p>It should also be noted, that orientations are sensitiv with respect to the alignment of the Euclidean reference frame 
  {% include inline_image.html file="CrystalOrientations_eq04350167453634413328.png" %}
, 
  {% include inline_image.html file="CrystalOrientations_eq06414813461508622197.png" %}
, 
  {% include inline_image.html file="CrystalOrientations_eq12012290346541195665.png" %}
 with respect to the crystal axes 
  {% include inline_image.html file="CrystalOrientations_eq05953740212242508018.png" %}
, 
  {% include inline_image.html file="CrystalOrientations_eq05190905986462978051.png" %}
 and 
  {% include inline_image.html file="CrystalOrientations_eq04815523992820898473.png" %}
. This issue is discussed in more detail in the topic <a href="CrystalReferenceSystem.html">The crystal reference system</a>.</p><h2 id="16">Defining crystal orientations</h2><p>Since, orientations are essentialy rotations with respect to a crystal reference frame all parameterisations of rotations may be applied to define orientations. Those include</p><h2 id="17">SUB: by Euler angles</h2><p>Here an orientation is determined by three consecutive rotations in the sample reference frame. The first is about the z-axis, the second about the x-axis, and the third again about the z-axis. The corresponding three angles are called  Euler angles and commonly denoted by phi1, Phi, phi2.</p><pre class="codeinput">ori = orientation.byEuler(30*degree,50*degree,10*degree,cs)
</pre><pre class="codeoutput"> 
ori = orientation  
  size: 1 x 1
  crystal symmetry : Olivin (mmm)
  specimen symmetry: 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    30   50   10    0
 
</pre><p>MTEX supports a varity of other Euler angle conventions which use different axes of rotation as discuses in the topic <a href="EulerAngleConventions.html">Euler angle conventions</a>.</p><h2 id="19">SUB: by rotational axis and rotational angle</h2><p>Another possibility to specify an orientation is to give its rotational axis and its rotational angle.</p><pre class="codeinput">ori = orientation.byAxisAngle(xvector,30*degree,cs)
</pre><pre class="codeoutput"> 
ori = orientation  
  size: 1 x 1
  crystal symmetry : Olivin (mmm)
  specimen symmetry: 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0   30    0    0
 
</pre><h2 id="20">SUB: by Miller indices</h2><p>There is also a Miller indice convention for defining crystal orientations.</p><pre class="codeinput">ori = orientation.byMiller([1 0 0],[0 1 1],cs)
</pre><pre class="codeoutput"> 
ori = orientation  
  size: 1 x 1
  crystal symmetry : Olivin (mmm)
  specimen symmetry: 1
 
  Bunge Euler angles in degree
     phi1     Phi    phi2    Inv.
  120.369      90      90       0
 
</pre><h2 id="21">SUB: defining an orientation by a 3 times 3 matrix</h2><pre class="codeinput">ori = orientation.byMatrix(eye(3),cs)
</pre><pre class="codeoutput"> 
ori = orientation  
  size: 1 x 1
  crystal symmetry : Olivin (mmm)
  specimen symmetry: 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0    0    0    0
 
</pre><h2 id="22">SUB: predefined orientations</h2><p>MTEX includes a list of standard standard orientations. For example the identical or cube orientation can be defined by the syntax</p><pre class="codeinput">ori = orientation.id(cs)
</pre><pre class="codeoutput"> 
ori = orientation  
  size: 1 x 1
  crystal symmetry : Olivin (mmm)
  specimen symmetry: 1
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
     0    0    0    0
 
</pre><p>In the samy way the following orientations can be defined: cube, brass, brass2, copper, copper2, cubeND22, cubeND45, cubeRD, goss, inverse goss, PLage, PLage2, QLage, QLage2, QLage3, QLage4, SR, SR2, SR3, SR4.</p><p>Note that a list of orientations can be defined using the same syntax as for the matlab commands ones, zeros, ..</p><pre class="codeinput">ori = orientation.id(100,1,cs)
</pre><pre class="codeoutput"> 
ori = orientation  
  size: 100 x 1
  crystal symmetry : Olivin (mmm)
  specimen symmetry: 1
 
</pre><h2 id="24">SUB: random orientations</h2><p>You may generate random orientations with</p><pre class="codeinput">ori = orientation.rand(1000,cs)
</pre><pre class="codeoutput"> 
ori = orientation  
  size: 1000 x 1
  crystal symmetry : Olivin (mmm)
  specimen symmetry: 1
 
</pre><h2 id="25">SUB: grids of orientations</h2><p>In many usecases one is interested in grid of orientations that somehow uniformely cover the orientation space. As there are many different grid there is a seperate topic <a href="SO3GridDemo.html">orientation grids</a>. The simplest way of generating equispaced orientations with given resolution is by the command</p><pre class="codeinput">ori = equispacedSO3Grid(cs,<span class="string">'resolution'</span>,2.5*degree)
</pre><pre class="codeoutput"> 
ori = SO3Grid  
  symmetry: "mmm" - "1"
  grid    : 237456 orientations, resolution: 2.5&deg;
</pre><h2 id="26">Specimen Symmetry</h2><p>If the texture forming process has been symmetric the resulting is often as well. The resulting symmetry is then aligned with the specimen reference system. In MTEX specimen symmetry axes may only be defined parallel to the specimen axes x, y, and z. The syntax is very similar to the definition of crystal symmetries.</p><pre class="codeinput"><span class="comment">% define cubic crystal symmetry</span>
cs = crystalSymmetry(<span class="string">'432'</span>)

<span class="comment">% and orthorhombic specimen symmetry</span>
ss = specimenSymmetry(<span class="string">'222'</span>)
</pre><pre class="codeoutput"> 
cs = crystalSymmetry  
 
  symmetry: 432    
  a, b, c : 1, 1, 1
 
 
ss = orthorhombic specimenSymmetry  
 
</pre><p>Orientations that respect crystal as well as specimen symmetries are defined by passign the specimen symmetry as an additional argument after the crystal symmetry.</p><pre class="codeinput">ori = orientation.brass(cs,ss)
</pre><pre class="codeoutput"> 
ori = orientation  
  size: 1 x 1
  crystal symmetry : 432
  specimen symmetry: 222
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    35   45    0    0
 
</pre><h2 id="28">Symmetrical Equivalent Orientations</h2><p>Crystal orientations always appear as a class of symmetrically equivalent orientations which are physicaly not distinguishable. For a given orientation <tt>ori</tt> the complete list of all symmetrically equivalent orientations is computed by the command <a href="orientation.symmetrise.html">symmetrise</a></p><pre class="codeinput">symmetrise(ori)
</pre><pre class="codeoutput"> 
ans = orientation  
  size: 96 x 1
  crystal symmetry : 432
  specimen symmetry: 222
 
</pre><p>Alternatively the list can be computed by multiplying with the specimen and the crystal symmetry from the left and from the right.</p><pre class="codeinput">ss * ori * cs
</pre><pre class="codeoutput"> 
ans = orientation  
  size: 4 x 24
  crystal symmetry : 432
  specimen symmetry: 222
 
</pre><p>For specific orientations as for the brass orientations symmetrisation leads to multiple identical orientation. This can be prevented by passing the option <tt>unique</tt> to the command <a href="orientation.symmetrise.html">symmetrise</a></p><pre class="codeinput">symmetrise(ori,<span class="string">'unique'</span>)
</pre><pre class="codeoutput"> 
ans = orientation  
  size: 48 x 1
  crystal symmetry : 432
  specimen symmetry: 222
 
</pre><p>Note that all operation on orientations are preformed taking all symmetrically equivalent orientations into account. As an example consider the angle between a random orientation and all orientations symmetricall equivalent to the goss orientation</p><pre class="codeinput">ori = orientation.rand(cs);
angle(ori,symmetrise(orientation.goss(cs))) ./ degree
</pre><pre class="codeoutput">ans =
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
   53.1373
</pre><p>The value is the same for all orientations and equal to the smallest angle to one of the symmetrally equivalent orientations. This can be verified by computing the rotational angle ignoring symmetry.</p><pre class="codeinput">angle(ori,symmetrise(orientation.goss(cs)),<span class="string">'noSymmetry'</span>) ./ degree
</pre><pre class="codeoutput">ans =
   92.1768
   53.8266
  157.1430
  124.3549
  170.0840
  112.8318
   74.8199
  136.9823
  129.3612
  169.8179
  153.2139
  142.6295
  129.0934
  136.1764
   73.1738
  140.0953
  152.0913
  168.5113
  158.5010
   53.1373
   89.8741
  110.3149
  167.4379
  124.9782
</pre><p>Functions that respect crystal symmetry but allow to switch it off using the flag <tt>noSymmetry</tt> include <a href="orientation_dot.html">dot</a>, <a href="orientation_unique.html">unique</a>, <a href="cluster.html">cluster</a></p><h2 id="34">Conversion into Euler angles, matrix, quaternion or Rodrigues vector</h2><p>There are methods to transform quaternion in almost any other of rotations as they are:</p><pre class="codeinput"><span class="comment">% as Euler angles</span>
ori.phi1, ori.Phi, ori.phi2

<span class="comment">% as quaternion</span>
quaternion(ori)

<span class="comment">% as matrix</span>
ori.matrix

<span class="comment">% as Rodrigues vector</span>
ori.Rodrigues
</pre><pre class="codeoutput">ans =
    1.6005
ans =
    1.0535
ans =
    6.2680
 
ans = Quaternion  
  size: 1 x 1
         a        b        c        d
  0.606796 0.347393 0.363366 0.615696
ans =
   -0.0222   -0.4947    0.8688
    0.9997    0.0005    0.0259
   -0.0132    0.8690    0.4946
 
ans = vector3d  
 size: 1 x 1
         x        y        z
  0.572505 0.598828  1.01467
</pre><h2 id="35">Plotting Orientations</h2><p>Orientations can be visualized in many different ways. The most popular way are <a href="OrientationPoleFigure.html">pole figures</a></p><pre class="codeinput">ori = orientation.rand(5,cs);
plotPDF(ori,Miller({1,0,0},{1,1,1},{1,1,0},cs))
</pre>
  {% include inline_image.html file="CrystalOrientations_01.png" %}
<p>Other options are <a href="OrientationInversePoleFigure.html">inverse pole figures</a>, <a href="EulerAngleSections.html">sections through the Euler space</a> and <a href="OrientationPlot3d">three dimensional orientation plots</a>.</p><pre class="codeinput"><span class="comment">% in Euler angle space</span>
plot(ori,<span class="string">'filled'</span>)
</pre>
  {% include inline_image.html file="CrystalOrientations_02.png" %}
<p>in axis angle space</p><pre class="codeinput">plot(ori,<span class="string">'axisAngle'</span>,<span class="string">'filled'</span>)
</pre>
  {% include inline_image.html file="CrystalOrientations_03.png" %}
</div></body></html>