---
title: CSL Boundaries
last_updated: 27-Oct-2019
sidebar: documentation_sidebar
permalink: CSLBoundaries.html
folder: documentation
toc: false
---

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>CSL Boundaries</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-10-27"><meta name="DC.source" content="script_CSLBoundaries.m"></head><body><font size="2"><a href="/documentation/Contribute2Doc.html" data-toggle="tooltip" data-original-title="To edit this page type edit CSLBoundaries into the Matlab commandline">edit page</a></font><div><!--introduction--><!--/introduction--><p>In this section we consider the analysis of CSL boundaries. Therefore lets start by importing some Iron data and reconstructing the grain structure.</p>
{% highlight matlab %}
mtexdata csl
plotx2east

% grain segementation
[grains,ebsd.grainId] = calcGrains(ebsd('indexed'));

% grain smoothing
grains = smooth(grains,2);

% plot the result
plot(grains,grains.meanOrientation)
{% endhighlight %}

{% highlight plaintext %}
 
ebsd = EBSD  
 
 Phase   Orientations  Mineral         Color  Symmetry  Crystal reference frame
    -1  154107 (100%)     iron  LightSkyBlue      m-3m                         
 
 Properties: ci, error, iq, x, y
 Scan unit : um
 

{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_01.png" %}
</center><p>Next we plot image quality as it makes the grain boundaries visible. and overlay it with the orientation map</p>
{% highlight matlab %}
plot(ebsd,log(ebsd.prop.iq),'figSize','large')
mtexColorMap black2white
CLim(gcm,[.5,5])

% the option 'FaceAlpha',0.4 makes the plot a bit transluent
hold on
plot(grains,grains.meanOrientation,'FaceAlpha',0.4)
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_02.png" %}
</center><h2 id="3">Detecting CSL Boundaries</h2><p>In order to detect CSL boundaries within the data set we first restrict the grain boundaries to iron to iron phase transitions and check then the boundary misorientations to be a CSL(3) misorientation with threshold of 3 degree.</p>
{% highlight matlab %}
% restrict to iron to iron phase transition
gB = grains.boundary('iron','iron')

% select CSL(3) grain boundaries
gB3 = gB(angle(gB.misorientation,CSL(3,ebsd.CS)) < 3*degree);

% overlay CSL(3) grain boundaries with the existing plot
hold on
plot(gB3,'lineColor','g','linewidth',2,'DisplayName','CSL 3')
hold off
{% endhighlight %}

{% highlight plaintext %}
 
gB = grainBoundary  
 
 Segments  mineral 1  mineral 2
    20356       iron       iron

{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_03.png" %}
</center><h2 id="4">Mark triple points</h2><p>Next we want to mark all triple points with at least 2 CSL boundaries</p>
{% highlight matlab %}
% logical list of CSL boundaries
isCSL3 = grains.boundary.isTwinning(CSL(3,ebsd.CS),3*degree);

% logical list of triple points with at least 2 CSL boundaries
tPid = sum(isCSL3(grains.triplePoints.boundaryId),2)>=2;

% plot these triple points
hold on
plot(grains.triplePoints(tPid),'color','r')
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_04.png" %}
</center><h2 id="5">Merging grains with common CSL(3) boundary</h2><p>Next we merge all grains together which have a common CSL(3) boundary. This is done with the command <a href="grain2d.merge.html">merge</a>.</p>
{% highlight matlab %}
% this merges the grains
[mergedGrains,parentIds] = merge(grains,gB3);

% overlay the boundaries of the merged grains with the previous plot
hold on
plot(mergedGrains.boundary,'linecolor','w','linewidth',2)
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_05.png" %}
</center><p>Finaly, we check for all other types of CSL boundaries and overlay them with our plot.</p>
{% highlight matlab %}
delta = 5*degree;
gB5 = gB(gB.isTwinning(CSL(5,ebsd.CS),delta));
gB7 = gB(gB.isTwinning(CSL(7,ebsd.CS),delta));
gB9 = gB(gB.isTwinning(CSL(9,ebsd.CS),delta));
gB11 = gB(gB.isTwinning(CSL(11,ebsd.CS),delta));

hold on
plot(gB5,'lineColor','b','linewidth',2,'DisplayName','CSL 5')
hold on
plot(gB7,'lineColor','r','linewidth',2,'DisplayName','CSL 7')
hold on
plot(gB9,'lineColor','m','linewidth',2,'DisplayName','CSL 9')
hold on
plot(gB11,'lineColor','c','linewidth',2,'DisplayName','CSL 11')
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_06.png" %}
</center><h2 id="7">Colorizing misorientations</h2><p>In the previous sections we have checked whether the boundary misorientations belong to certain specific classes of misorientations. In order to analyze the distribution of misorientations we may colorize the grain boundaries according to their misorientation. See S. Patala, J. K. Mason, and C. A. Schuh, 2012, for details. The coresponding orientation to color mapping is implemented into MTEX as</p>
{% highlight matlab %}
moriKey = PatalaColorKey(gB)
{% endhighlight %}

{% highlight plaintext %}
moriKey = 
  PatalaColorKey with properties:

          CS1: [24&times;2 crystalSymmetry]
          CS2: [24&times;2 crystalSymmetry]
    antipodal: 1

{% endhighlight %}
<p>Colorizing the grain boundaries is now straight forward</p>
{% highlight matlab %}
plot(ebsd,log(ebsd.prop.iq),'figSize','large')
mtexColorMap black2white
CLim(gcm,[.5,5])

% and overlay it with the orientation map
hold on
plot(grains,grains.meanOrientation,'FaceAlpha',0.4)

hold on
plot(gB,moriKey.orientation2color(gB.misorientation),'linewidth',2)
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_07.png" %}
</center><p>Lets examine the colormap. We plot it as axis angle sections and add 300 random boundary misorientations on top of it. Note that in this plot misorientations <tt>mori</tt> and <tt>inv(mori)</tt> are associated.</p>
{% highlight matlab %}
plot(moriKey,'axisAngle',(5:5:60)*degree)

plot(gB.misorientation,'points',300,'add2all',...
  'MarkerFaceColor','none','MarkerEdgeColor','w')
{% endhighlight %}

{% highlight plaintext %}
  plotting 300 random orientations out of 20356 given orientations

{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_08.png" %}
</center><h2 id="10">Misorientations in the 3d fundamental zone</h2><p>We can also look at the boundary misorienations in the 3 dimensional fundamental orientation zone.</p>
{% highlight matlab %}
% compute the boundary of the fundamental zone
oR = fundamentalRegion(moriKey.CS1,moriKey.CS2,'antipodal');
close all
plot(oR)

% plot 500 random misorientations in the 3d fundamenal zone
mori = discreteSample(gB.misorientation,500);
hold on
plot(mori.project2FundamentalRegion)
hold off


% mark the CSL(3) misorientation
hold on
csl3 = CSL(3,ebsd.CS);
plot(csl3.project2FundamentalRegion('antipodal') ,'MarkerColor','r','DisplayName','CSL 3','MarkerSize',20)
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_09.png" %}
</center><h2 id="11">Analyzing the misorientation distribution function</h2><p>In order to analyze more quantitatively the boundary misorientation distribution we can compute the so called misorientation distribution function. The option <tt>antipodal</tt> is applied since we want to identify <tt>mori</tt> and <tt>inv(mori)</tt>.</p>
{% highlight matlab %}
mdf = calcMDF(gB.misorientation,'halfwidth',2.5*degree,'bandwidth',32)
{% endhighlight %}

{% highlight plaintext %}
 
mdf = MDF  
  crystal symmetry : iron (m-3m)
  crystal symmetry : iron (m-3m)
  antipodal:         true
 
  Harmonic portion:
    degree: 32
    weight: 1
 

{% endhighlight %}
<p>Next we can visualize the misorientation distribution function in axis angle sections.</p>
{% highlight matlab %}
plot(mdf,'axisAngle',(25:5:60)*degree,'colorRange',[0 15])

annotate(CSL(3,ebsd.CS),'label','$CSL_3$','backgroundcolor','w')
annotate(CSL(5,ebsd.CS),'label','$CSL_5$','backgroundcolor','w')
annotate(CSL(7,ebsd.CS),'label','$CSL_7$','backgroundcolor','w')
annotate(CSL(9,ebsd.CS),'label','$CSL_9$','backgroundcolor','w')

drawNow(gcm)
{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_10.png" %}
</center><p>The MDF can be now used to compute prefered misorientations</p>
{% highlight matlab %}
mori = mdf.calcModes(2)
{% endhighlight %}

{% highlight plaintext %}
 
mori = misorientation  
  size: 1 x 2
  crystal symmetry : iron (m-3m)
  crystal symmetry : iron (m-3m)
 
  Bunge Euler angles in degree
     phi1     Phi    phi2    Inv.
   243.71 48.3206 152.606       0
  98.0317 38.0679 227.755       0
 

{% endhighlight %}
<p>and their volumes in percent</p>
{% highlight matlab %}
100 * volume(gB.misorientation,CSL(3,ebsd.CS),2*degree)

100 * volume(gB.misorientation,CSL(9,ebsd.CS),2*degree)
{% endhighlight %}

{% highlight plaintext %}
ans =
   40.9904
ans =
    2.0338

{% endhighlight %}
<p>or to plot the MDF along certain fibres</p>
{% highlight matlab %}
omega = linspace(0,55*degree);
fibre100 = orientation.byAxisAngle(xvector,omega,mdf.CS,mdf.SS)
fibre111 = orientation.byAxisAngle(vector3d(1,1,1),omega,mdf.CS,mdf.SS)
fibre101 = orientation.byAxisAngle(vector3d(1,0,1),omega,mdf.CS,mdf.SS)

close all
plot(omega ./ degree,mdf.eval(fibre100))
hold on
plot(omega ./ degree,mdf.eval(fibre111))
plot(omega ./ degree,mdf.eval(fibre101))
hold off
legend('100','111','101')
{% endhighlight %}

{% highlight plaintext %}
 
fibre100 = misorientation  
  size: 1 x 100
  crystal symmetry : iron (m-3m)
  crystal symmetry : iron (m-3m)
 
 
fibre111 = misorientation  
  size: 1 x 100
  crystal symmetry : iron (m-3m)
  crystal symmetry : iron (m-3m)
 
 
fibre101 = misorientation  
  size: 1 x 100
  crystal symmetry : iron (m-3m)
  crystal symmetry : iron (m-3m)
 

{% endhighlight %}
<center>
{% include inline_image.html file="CSLBoundaries_11.png" %}
</center><p>or to evaluate it in an misorientation directly</p>
{% highlight matlab %}
mori = orientation.byEuler(15*degree,28*degree,14*degree,mdf.CS,mdf.CS)

mdf.eval(mori)
{% endhighlight %}

{% highlight plaintext %}
 
mori = misorientation  
  size: 1 x 1
  crystal symmetry : iron (m-3m)
  crystal symmetry : iron (m-3m)
 
  Bunge Euler angles in degree
  phi1  Phi phi2 Inv.
    15   28   14    0
 
ans =
    5.6826

{% endhighlight %}
</div></body></html>