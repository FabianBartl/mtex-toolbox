---
title: Harmonic Representation of Spherical Functions
last_updated: 04-Nov-2019
sidebar: documentation_sidebar
permalink: S2FunHarmonicRepresentation.html
folder: documentation
toc: false
---
    <html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Harmonic Representation of Spherical Functions</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-11-04"><meta name="DC.source" content="script_S2FunHarmonicRepresentation.m"></head><body><font size="2"><a href="https://github.com/mtex-toolbox/mtex/blob/develop/doc/SphericalFunctions/S2FunHarmonicRepresentation.m">
    edit page</a></font><div><!--introduction--><p>The class <a href="S2FunHarmonic.S2FunHarmonic"><code class="language-plaintext highlighter-rouge">S2FunHarmonic</code></a> is the heart of S2Fun, therefore, much effort is put into its functionality. So lets cover the mathematical basics. The general problem is to approximate functions of the form \(f\colon \bf S^2\to \bf R\).</p><!--/introduction--><p>For that we use linear combinations of spherical harmonics, which constitude a basis of all square-integrable functions on the sphere \(L_2(\bf S^2)\). The spherical harmonic of degree \(m\) and order \(l\) is defined by</p><p>\[ Y_{m,l}(\theta, \rho) = \sqrt{\frac{2m+1}{4\pi}}P_{m,|l|}(\cos\rho)\mathrm e^{\mathrm i l\theta} \]</p><p>for \(P_{m,|l|}\) being the associated Legendre-Polynomial, \(m\in\bf N_0\), and \(<code class="language-plaintext highlighter-rouge">l</code>\le m\). The first ten spherical harmonics look as follows</p>
{% highlight matlab %}
surf(S2FunHarmonic(eye(10)))
{% endhighlight %}
<center>
{% include inline_image.html file="S2FunHarmonicRepresentation_01.png" %}
</center><p>If you think you remember these from the Windows 2000 flowerbox screensaver, you are wrong. But they play a fundamental role in the computation of atomic orbital electron configurations and may have appeared in a chemistry book you've seen.</p><p>Now we seek for so-called Fourier-coefficients \(\bf{\hat f} = (\hat f_{0,0},\dots,\hat f_{M,M})^T\) such that</p><p>\[ g(x) = \sum_{m=0}^M\sum_{l = -m}^m \hat f_{m,l} Y_{m,l}(x) \]</p><p>approximates our function. A basic strategy to achieve this is through least squares, where we minimize the functional \[ \sum_{n=1}^N|f(x_n)-g(x_n)|^2 \]</p><p>for the data nodes \(x_n\), \(n=1,\dots,N\), \(f(x_n)\) the target function values and \(g(x_n)\) our approximation evaluated in the given data nodes.</p><p>This can be done by the <code class="language-plaintext highlighter-rouge">lsqr</code> function of Matlab, which efficiently seeks for roots of the derivative of the given functional (also known as normal equation). In the process we compute the matrix-vector product with the Fourier-matrix multible times, where the Fourier-matrix is given by</p><p>\[ F = [Y_{m,l}(x_n)]_{n = 1,\dots,N;m = 0,\dots,M,l = -m,\dots,m}. \]</p><p>This matrix-vector product can be computed efficiently with the use of the nonequispaced spherical Fourier transform <a href="https://www-user.tu-chemnitz.de/~potts/nfft/nfsft.php">NFSFT</a>.</p><p>We end up with the Fourier-coefficients of our approximation \(g\), which describe our approximation.</p><p>There are other variants to obtain these Fourier-coefficients, but we only wanted to give a feel for what they are for.</p></div></body></html>