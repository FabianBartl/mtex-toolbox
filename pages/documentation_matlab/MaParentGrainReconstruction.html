---
title: Martensite Parent Grain Reconstruction
last_updated: 26-Jun-2020
sidebar: documentation_sidebar
permalink: MaParentGrainReconstruction.html
folder: documentation
toc: false
---
    <html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Martensite Parent Grain Reconstruction</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-06-26"><meta name="DC.source" content="script_MaParentGrainReconstruction.m"></head><body><font size="2"><a href="https://github.com/mtex-toolbox/mtex/blob/develop/doc/PhaseTransistions/MaParentGrainReconstruction.m">
    edit page</a></font><div><!--introduction--><!--/introduction--><p>This script demonstrates the tools MTEX offers to reconstruct a parent martensite phase from a measured austenite phase. Most of the ideas are from <a href="https://www.researchgate.net/deref/http%3A%2F%2Fdx.doi.org%2F10.1007%2Fs11661-018-4904-9?_sg%5B0%5D=gRJGzFvY4PyFk-FFoOIj2jDqqumCsy3e8TU6qDnJoVtZaeUoXjzpsGmpe3TDKsNukQYQX9AtKGniFzbdpymYvzYwhg.5jfOl5Ohgg7pW_6yACRXN3QiR-oTn8UsxZjTbJoS_XqwSaaB7r8NgifJyjSES2iXP6iOVx57sy8HC4q2XyZZaA">Crystallography, Morphology, and Martensite Transformation of Prior Austenite in Intercritically Annealed High-Aluminum Steel</a> by Tuomo Nyyss&ouml;nen. We shall use the following sample data set.</p>
{% highlight matlab %}
% load the data
mtexdata martensite

% extract fcc and bcc symmetries
csBCC = ebsd.CSList{2}; % austenite bcc:
csFCC = ebsd.CSList{3}; % martensite fcc:

% grain reconstruction
[grains,ebsd.grainId] = calcGrains(ebsd('indexed'),'angle',3*degree);

% remove small grains
ebsd(grains(grains.grainSize < 4)) = [];

% reidentify grains with small grains removed:
[grains,ebsd.grainId] = calcGrains(ebsd('indexed'),'angle',3*degree);

% plot the data and the grain boundaries
plot(ebsd('Iron bcc'),ebsd('Iron bcc').orientations,'figSize','large')
hold on
plot(grains.boundary,'linewidth',2)
hold off
{% endhighlight %}

{% highlight plaintext %}
ebsd = EBSD  
 
 Phase  Orientations         Mineral         Color  Symmetry  Crystal reference frame
     0   92415 (27%)      notIndexed                                                 
     1  251187 (73%)  Iron bcc (old)  LightSkyBlue       432                         
 
 Properties: bands, bc, bs, error, mad, reliabilityindex, x, y
 Scan unit : um
{% endhighlight %}
<center>
{% include inline_image.html file="MaParentGrainReconstruction_01.png" %}
</center><h2 id="2">Determine the parent child orientation relationship</h2><p>It is well known that the phase transformation from martensite to austenite is not described by a fixed orientation relationship. In fact, the actual orientation relationship needs to be determined for each sample individualy. Here, we used the iterative methos proposed by Tuomo Nyyss&ouml;nen and implemented in the function <a href="calcParent2Child.html"><code class="language-plaintext highlighter-rouge">calcParent2Child</code></a> that starts at an initial guess of the orientation relation ship and iterates towards the true orientation relationship.</p><p>Here we use as the initial guess the Kurdjumov Sachs orientation relationship</p>
{% highlight matlab %}
% initial gues is Kurdjumov Sachs
KS = orientation.KurdjumovSachs(csFCC,csBCC);
{% endhighlight %}
<p>The function <a href="calcParent2Child.html"><code class="language-plaintext highlighter-rouge">calcParent2Child</code></a> requires as input a list of child to child misorientations or, equivalently, a two column matrix of child orientations. Here we go with the second option and setup this two column orientation matrix from the mean orientations of neighbouring grains which can be found using the command <a href="grain2d.neighbours.html"><code class="language-plaintext highlighter-rouge">neighbours</code></a></p>
{% highlight matlab %}
% get neighbouring grain pairs
grainPairs = grains.neighbors;

% compute an optimal parent to child orientation relationship
[fcc2bcc, fit] = calcParent2Child(grains(grainPairs).meanOrientation,KS);

% display the distribution of disorientations with respect to this
% orientation relationship
close all
histogram(fit./degree)
xlabel('disorientation angle')
{% endhighlight %}
<center>
{% include inline_image.html file="MaParentGrainReconstruction_02.png" %}
</center><h2 id="4">Create a similarity matrix</h2><p>Next we set up a adjecency matrix <code class="language-plaintext highlighter-rouge">A</code> that describes the probability that two neighbouring grains belong to the same parent grains. This probability is is computed from the misfit of misorientation between to child grains to the theoretical child to child misorientation. More precisely, we model the probability by a cumulativ Gaussian distribution with mean value <code class="language-plaintext highlighter-rouge">threshold</code> which describes the misfit at which the probability is exactly 50 percent and the standard deviation <code class="language-plaintext highlighter-rouge">tol</code></p>
{% highlight matlab %}
omega = linspace(0,5)*degree;
threshold = 2*degree;
tol = 1.5*degree;

close all
plot(omega./degree,1 - 0.5 * (1 + erf(2*(omega - threshold)./tol)),'linewidth',2)
xlabel('misfit in degree')
ylabel('probability')
{% endhighlight %}
<center>
{% include inline_image.html file="MaParentGrainReconstruction_03.png" %}
</center><p>The above diagram describes the probablity distribution as a function of the misfit. After filling the matrix <code class="language-plaintext highlighter-rouge">A</code> with these probabilities</p>
{% highlight matlab %}
% compute the probabilities
prob = 1 - 0.5 * (1 + erf(2*(fit - threshold)./tol));

% the corresponding similarity matrix
A = sparse(grainPairs(:,1),grainPairs(:,2),prob,length(grains),length(grains));
{% endhighlight %}
<p>we can split it into clusters using the command <a href="calcCluster.html"><code class="language-plaintext highlighter-rouge">calcCluster</code></a> which implements the <a href="https://micans.org/mcl">Markovian clustering algorithm</a>. Here an important parameter is the so called inflation power, which controls the size of the clusters.</p>
{% highlight matlab %}
p = 1.6; % inflation power:
A = mclComponents(A,p);
{% endhighlight %}
<p>Each connected component of the resulting adjecency matrix describes one parent grain. Hence, we can use this adjecency matrix to merge child grains into parent grains by the command <a href="graind2d.merge.html"><code class="language-plaintext highlighter-rouge">merge</code></a>.</p>
{% highlight matlab %}
% merge grains according to the adjecency matrix A
[parentGrains, parentId] = merge(grains,A);

% ensure grainId in parentEBSD is set up correctly with parentGrains
parentEBSD = ebsd;
parentEBSD('indexed').grainId = parentId(ebsd('indexed').grainId);
{% endhighlight %}
<p>Lets visualize the first result. Note, that at this stage it is not important to have the parent grain already at their optimal size. Similarly orientated grains can be merged later on.</p>
{% highlight matlab %}
plot(ebsd('Iron bcc'),ebsd('Iron bcc').orientations,'figSize','large')
hold on;
plot(parentGrains.boundary,'linewidth',5)
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="MaParentGrainReconstruction_04.png" %}
</center><h2 id="9">Compute parent grain orientations</h2><p>In the next step we compute for each parent grain its parent martensite orientation. This can be done usig the command <a href="calcParent.html"><code class="language-plaintext highlighter-rouge">calcParent</code></a>. Note, that we ensure that et least two child grains have been merged and that the misfit is smaller the 5 degree.</p>
{% highlight matlab %}
% the measured child orientations
childOri = grains('Iron bcc').meanOrientation;

% the parent orientation we are going to compute
parentOri = orientation.nan(max(parentId),1,fcc2bcc.CS);
fit = inf(size(parentOri));
weights = grains('Iron bcc').grainSize;

% loop through all parent grains
for k = 1:max(parentId)
  if nnz(parentId==k) > 1
    % compute the parent orientation from the child orientations
    [parentOri(k),fit(k)] = calcParent(childOri(parentId==k), fcc2bcc,'weights',weights((parentId==k)));
  end
  progress(k,max(parentId));
end

% update mean orientation of the parent grains
parentGrains(fit<5*degree).meanOrientation = parentOri(fit<5*degree);
parentGrains = parentGrains.update;

% merge grains with similar orientation
%[parentGrains, parentId] = merge(parentGrains,'threshold',3*degree);
%parentEBSD('indexed').grainId = parentId(parentEBSD('indexed').grainId);
{% endhighlight %}
<p>Lets plot the resulting parent orientations</p>
{% highlight matlab %}
plot(parentGrains('Iron fcc'),parentGrains('Iron fcc').meanOrientation)
{% endhighlight %}
<center>
{% include inline_image.html file="MaParentGrainReconstruction_05.png" %}
</center><p>Once parent grain orientations have been computed we may use them to compute parent orientations of each pixel in our original EBSD map. To this end we first find a pixels that now belong to a martensite grain.</p>
{% highlight matlab %}
% consider only austenite pixels that now belong to martensite grains
isNowFCC = parentGrains.phaseId(max(1,parentEBSD.grainId)) == 3 & parentEBSD.phaseId == 2;

% compute parent orientation
[parentEBSD(isNowFCC).orientations, fit] = calcParent(ebsd(isNowFCC).orientations,...
  parentGrains(parentEBSD(isNowFCC).grainId).meanOrientation,fcc2bcc);

% plot the result
plot(parentEBSD('Iron fcc'),parentEBSD('Iron fcc').orientations,'figSize','large')
{% endhighlight %}
<center>
{% include inline_image.html file="MaParentGrainReconstruction_06.png" %}
</center><p>As a second output argument we obtain the <code class="language-plaintext highlighter-rouge">misfit</code> between the parent orientation computed for the pixel and the meanorientation of the corresponding parent grain. Lets plot this misfit as a map.</p>
{% highlight matlab %}
plot(parentEBSD(isNowFCC),fit ./ degree,'figSize','large')
mtexColorMap LaboTeX
mtexColorbar
{% endhighlight %}
<center>
{% include inline_image.html file="MaParentGrainReconstruction_07.png" %}
</center><h2 id="13">Denoise the parent map</h2><p>Finaly we may apply filtering to the parent map to fill non indexed or not reconstructed pixels. To this end we first run grain reconstruction on the parent map</p>
{% highlight matlab %}
[parentGrains, parentEBSD.grainId] = calcGrains(parentEBSD('indexed'),'angle',3*degree);

parentEBSD(parentGrains(parentGrains.grainSize<10)) = [];

[parentGrains, parentEBSD.grainId] = calcGrains(parentEBSD('indexed'),'angle',3*degree);
parentGrains = smooth(parentGrains,5);

plot(ebsd('indexed'),ebsd('indexed').orientations,'figSize','large')

hold on
plot(parentGrains.boundary,'lineWidth',2)
hold off

hold on
plot(parentGrains.boundary,'lineWidth',2)
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="MaParentGrainReconstruction_08.png" %}
</center><p>and then use the command <a href="EBSD.smooth.html"><code class="language-plaintext highlighter-rouge">smooth</code></a> to fill the holes in the reconstructed parent map</p>
{% highlight matlab %}
% fill the holes
F = halfQuadraticFilter;
parentEBSD = smooth(parentEBSD('indexed'),F,'fill',parentGrains);

% plot the parent map
plot(parentEBSD('Iron fcc'),parentEBSD('Iron fcc').orientations,'figSize','large')

% with grain boundaries
hold on
plot(parentGrains.boundary,'lineWidth',2)
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="MaParentGrainReconstruction_09.png" %}
</center><h2 id="15">Summary of relevant thresholds</h2><p>In the above script several parameters are decicive for the success of the reconstruction</p><div><ul><li>threshold for initial grain segmentation (3 degree)</li><li>theshold (2 degree), tolerance (1.5 degree) and inflation power (p = 1.6) of the Markovian clustering algorithm</li><li>maximum misfit within a parent grain (5 degree)</li><li>minimum number of merged childs</li></ul></div></div></body></html>