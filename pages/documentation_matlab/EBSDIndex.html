---
title: The Index of EBSD data

sidebar: documentation_sidebar
permalink: EBSDIndex.html
folder: documentation
toc: false
---
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
    -->
<title>The Index of EBSD data</title>
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.source" content="script_EBSDIndex.m">
</head>
<body>
<font size="2"><a href="https://github.com/mtex-toolbox/mtex/blob/develop/doc/EBSDAnalysis/EBSDIndex.m">
    edit page</a></font>
<div>
<!--introduction-->
<!--/introduction-->
<p>In previous chapters we have discussed how to select EBSD data by properties. In this chapter we are intested in the order the EBSD are stored within MTEX. Lets start by importing some sample data</p>
{% highlight matlab %}
mtexdata twins
{% endhighlight %}

{% highlight plaintext %}
ebsd = EBSD
 
 Phase  Orientations     Mineral         Color  Symmetry  Crystal reference frame
     0     46 (0.2%)  notIndexed                                                 
     1  22833 (100%)   Magnesium  LightSkyBlue     6/mmm       X||a*, Y||b, Z||c*
 
 <strong>Properties</strong>: bands, bc, bs, error, mad
 <strong>Scan unit</strong> : um
 <strong>X x Y x Z</strong> : [0 50] x [0 41] x [0 0]
 <strong>Normal vector</strong>: (0,0,1)
{% endhighlight %}
<p>and restricting it to very small rectangular subset</p>
{% highlight matlab %}
poly = [44 0 4 2];
ebsd = ebsd(inpolygon(ebsd,poly));

plot(ebsd,ebsd.orientations,'micronbar','off','edgecolor','k')
{% endhighlight %}
<center>
{% include inline_image.html file="EBSDIndex_01.png" %}
</center>
<p>In the above plot each square corresponds to one entry in the variable <code class="language-plaintext highlighter-rouge">ebsd</code>. Lets visualize the order</p>
{% highlight matlab %}
text(ebsd,1:length(ebsd))
{% endhighlight %}
<center>
{% include inline_image.html file="EBSDIndex_02.png" %}
</center>
<p>We may easily select specific measurement pixels by specifying their indeces</p>
{% highlight matlab %}
hold on
plot(ebsd(16:18),'edgeColor','red','facecolor','none','linewidth',4)
legend off
hold off
{% endhighlight %}

{% highlight plaintext %}
Warning: You asked me to make a phase plot of single phase map. This
might not what you are looking for. In order to colorize the map
according to the orientations you should do

<strong>plot(ebsd,ebsd.orientations)</strong>
{% endhighlight %}
<center>
{% include inline_image.html file="EBSDIndex_03.png" %}
</center>
<p>Whether lines or columns run first is not related to MTEX but inherits from the ordering of the imported EBSD data. Since, we have restricted our large EBSD map to the small subset the indece of restricted data does not coincide with the indece of the imported data anymore. However, the original indeces are still stored in <code class="language-plaintext highlighter-rouge">ebsd.id</code>. Lets visualize them</p>
{% highlight matlab %}
plot(ebsd,ebsd.orientations,'micronbar','off','edgecolor','k')
text(ebsd,ebsd.id)
{% endhighlight %}
<center>
{% include inline_image.html file="EBSDIndex_04.png" %}
</center>
<p>In order to select EBSD data according to their original id use the option <code class="language-plaintext highlighter-rouge">'id'</code>, i.e.,</p>
{% highlight matlab %}
hold on
plot(ebsd('id',316:318),'edgeColor','red','facecolor','none','linewidth',4)
legend off
hold off
{% endhighlight %}

{% highlight plaintext %}
Warning: You asked me to make a phase plot of single phase map. This
might not what you are looking for. In order to colorize the map
according to the orientations you should do

<strong>plot(ebsd,ebsd.orientations)</strong>
{% endhighlight %}
<center>
{% include inline_image.html file="EBSDIndex_05.png" %}
</center>
<h2 id="7">Square Grids</h2>
<p>In the cases of gridded data it is often useful to convert them into a matrix form.</p>
{% highlight matlab %}
ebsd = ebsd.gridify;

plot(ebsd,ebsd.orientations,'micronbar','off')

[i,j] = ndgrid(1:size(ebsd,1),1:size(ebsd,2));
str = arrayfun(@(a,b) ['(' int2str(a) ',' int2str(b) ')'],i,j,'UniformOutput',false);
text(ebsd,str)
{% endhighlight %}
<center>
{% include inline_image.html file="EBSDIndex_06.png" %}
</center>
<p>This allows to select EBSD data simply by their coordinates within the grid, e.g., by</p>
{% highlight matlab %}
hold on
plot(ebsd(2,2:4),'edgeColor','red','facecolor','none','linewidth',4)
legend off
hold off
{% endhighlight %}

{% highlight plaintext %}
Warning: You asked me to make a phase plot of single phase map. This
might not what you are looking for. In order to colorize the map
according to the orientations you should do

<strong>plot(ebsd,ebsd.orientations)</strong>
{% endhighlight %}
<center>
{% include inline_image.html file="EBSDIndex_07.png" %}
</center>
<p>Note that the <a href="EBSD.gridify.html"><code class="language-plaintext highlighter-rouge">gridify</code></a> command changes the order of measurements. They are now sort such that rows runs first and columns second, as this is the default convention how Matlab indexes matrices.</p>
{% highlight matlab %}
plot(ebsd,ebsd.orientations,'micronbar','off')
text(ebsd,1:length(ebsd))
{% endhighlight %}
<center>
{% include inline_image.html file="EBSDIndex_08.png" %}
</center>
<h2 id="10">Hexagonal Grid</h2>
<p>The command <a href="EBSD.gridify.html"><code class="language-plaintext highlighter-rouge">gridify</code></a> may also be applied to EBSD data measured on a hexagonal grid.</p>
{% highlight matlab %}
mtexdata titanium silent

ebsd = ebsd.gridify
{% endhighlight %}

{% highlight plaintext %}
ebsd = EBSDhex
 
 Phase  Orientations           Mineral         Color  Symmetry  Crystal reference frame
     0    8100 (99%)  Titanium (Alpha)  LightSkyBlue       622       X||a, Y||b*, Z||c*
 
 <strong>Properties</strong>: ci, grainid, iq, sem_signal, oldId
 <strong>Scan unit</strong> : um
 <strong>X x Y x Z</strong> : [0 1002] x [0 998] x [0 0]
 <strong>Normal vector</strong>: (0,0,1)
 Grid size (hex): 97 x 84
{% endhighlight %}
<p>This rearranges the measurements in a matrix form which can be indexed similarly as in the square case.</p>
{% highlight matlab %}
ebsd = ebsd(10:16,68:79);
{% endhighlight %}
<p>Lets visualize the matrix coordinates for the hexagonal grid</p>
{% highlight matlab %}
plot(ebsd,ebsd.orientations,'edgeColor','k','micronbar','off')
axis off

[i,j] = ndgrid(1:size(ebsd,1),1:size(ebsd,2));
str = arrayfun(@(a,b) ['(' int2str(a) ',' int2str(b) ')'],i,j,'UniformOutput',false);
text(ebsd,str)
{% endhighlight %}
<center>
{% include inline_image.html file="EBSDIndex_09.png" %}
</center>
<h2 id="13">Cube Coordinates</h2>
<p>In hexognal grids it is sometimes advantageous to use three digit cube coordinates to index the cell. This can be done using the commands <a href="EBSDhex.hex2cube.html"><code class="language-plaintext highlighter-rouge">hex2cube</code></a> and <a href="EBSDhex.cube2hex.html"><code class="language-plaintext highlighter-rouge">cube2hex</code></a>. Much more details on indexing hex grids can be found at <a href="https://www.redblobgames.com/grids/hexagons/">here</a>.</p>
{% highlight matlab %}
plot(ebsd,ebsd.orientations,'edgeColor','k','micronbar','off')
axis off

[i,j] = ndgrid(1:size(ebsd,1),1:size(ebsd,2));
[x,y,z] = ebsd.hex2cube(i,j);
str = arrayfun(@(a,b,c) ['(' int2str(a) ',' int2str(b) ',' int2str(c) ')'],x,y,z,'UniformOutput',false);
text(ebsd,str)
{% endhighlight %}
<center>
{% include inline_image.html file="EBSDIndex_10.png" %}
</center>
</div>
</body>
</html>
