---
title: Dislocation Density Estimation
last_updated: 11-Oct-2019
sidebar: documentation_sidebar
permalink: GND_demo.html
folder: documentation
toc: false
---

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Dislocation Density Estimation</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-10-11"><meta name="DC.source" content="script_GND_demo.m"></head><body><font size="2"><a href="#" data-toggle="tooltip" data-original-title="To edit this page type edit GND_demo into the Matlab commandline">edit page</a></font><div><!--introduction--><p>This example sheet describes how to estimate dislocation densities in MTEX following the reference paper</p><p>Pantleon, Resolving the geometrically necessary dislocation content by conventional electron backscattering diffraction, Scripta Materialia, 2008</p><!--/introduction--><h2 id="1">Data import and grain reconstruction</h2><p>Lets start by importing orientation data from 2 percent uniaxial deformed steel DC06 and visualize those data in an ipf map.</p>
{% highlight matlab %}
% set up the plotting convention
plotx2north

% import the EBSD data
ebsd = EBSD.load([mtexDataPath filesep 'EBSD' filesep 'DC06_2uniax.ang']);
%ebsd = EBSD.load('DC06_2biax.ang');

% define the color key
ipfKey = ipfHSVKey(ebsd);
ipfKey.inversePoleFigureDirection = yvector;

% and plot the orientation data
plot(ebsd,ipfKey.orientation2color(ebsd.orientations),'micronBar','off','figSize','medium')
{% endhighlight %}

  {% include inline_image.html file="GND_demo_01.png" %}
<p>In the next step we reconstruct grains, remove all grains with less then 5 pixels and smooth the grain boundaries.</p>
{% highlight matlab %}
% reconstruct grains
[grains,ebsd.grainId] = calcGrains(ebsd,'angle',5*degree);

% remove small grains
ebsd(grains(grains.grainSize&lt;=5)) = [];

% redo grain reconstruction
[grains,ebsd.grainId] = calcGrains(ebsd,'angle',2.5*degree);

% smooth grain boundaries
grains = smooth(grains,5);

hold on
plot(grains.boundary,'linewidth',2)
hold off
{% endhighlight %}

  {% include inline_image.html file="GND_demo_02.png" %}
<h2 id="3">Data cleaning</h2><p>The computation of geometrically neccesary dislocations from EBSD maps depends on local orientation changes in the map. In order to make those visible we switch to a different color key that colorises the misorientation of an pixel with respect to the grain meanorientation.</p>
{% highlight matlab %}
% a key the colorizes according to misorientation angle and axis
ipfKey = axisAngleColorKey(ebsd);

% set the grain mean orientations as reference orinetations
ipfKey.oriRef = grains(ebsd('indexed').grainId).meanOrientation;

% plot the data
plot(ebsd,ipfKey.orientation2color(ebsd('indexed').orientations),'micronBar','off','figSize','medium')

hold on
plot(grains.boundary,'linewidth',2)
hold off
{% endhighlight %}

  {% include inline_image.html file="GND_demo_03.png" %}
<p>We observe that the data are quite noisy. As noisy orientation data lead to overestimate the GND density we apply sime denoising techniques to the data.</p>
{% highlight matlab %}
% denoise orientation data
F = halfQuadraticFilter;
F.threshold = 1.5*degree;
F.eps = 1e-2;
F.alpha = 0.01;
ebsd = smooth(ebsd('indexed'),F,'fill',grains);

% plot the denoised data
ipfKey.oriRef = grains(ebsd('indexed').grainId).meanOrientation;
plot(ebsd('indexed'),ipfKey.orientation2color(ebsd('indexed').orientations),'micronBar','off','figSize','medium')

hold on
plot(grains.boundary,'linewidth',2)
hold off
{% endhighlight %}

{% highlight plaintext %}
 denoising EBSD data: 100%

{% endhighlight %}

  {% include inline_image.html file="GND_demo_04.png" %}
<h2 id="5">The incomplete curvature tensor</h2><p>Starting point of any GND computation is the curvature tensor, which is a rank two tensor that is defined for every pixel in the EBSD map by the directional derivatives in x, y and z direction.</p>
{% highlight matlab %}
% consider only the Fe(alpha) phase
ebsd = ebsd('indexed').gridify;

% compute the curvature tensor
kappa = ebsd.curvature

% one can index the curvature tensors in the same way as the EBSD data.
% E.g. the curvature in pixel (2,3) is
kappa(2,3)
{% endhighlight %}

{% highlight plaintext %}
 
kappa = curvatureTensor  
  size: 101 x 51 
  unit: 1/um     
  rank: 2 (3 x 3)
 
ans = curvatureTensor  
  unit: 1/um     
  rank: 2 (3 x 3)
 
 *10^-4
   1.767  15.127     NaN
  -5.178   1.493     NaN
 -12.003  16.171     NaN

{% endhighlight %}
<h2 id="6">The components of the curvature tensor</h2><p>As expected the curvature tensor is NaN in the third column as this column corresponds to the directional derivative in z-direction which is usually unknown for 2d EBSD maps.</p><p>We can access the different components of the curvature tensor with</p>
{% highlight matlab %}
kappa12 = kappa{1,2};

size(kappa12)
{% endhighlight %}

{% highlight plaintext %}
ans =
   101    51

{% endhighlight %}
<p>which results in a variable of the same size as our EBSD map. This allows us to visualize the different components of the curvature tensor</p>
{% highlight matlab %}
newMtexFigure('nrows',3,'ncols',3);

% cycle through all components of the tensor
for i = 1:3
  for j = 1:3

    nextAxis(i,j)
    plot(ebsd,kappa{i,j},'micronBar','off')
    hold on; plot(grains.boundary,'linewidth',2); hold off

  end
end

% unify the color rage  - you may also use setColoRange equal
setColorRange([-0.005,0.005])
drawNow(gcm,'figSize','large')
{% endhighlight %}

  {% include inline_image.html file="GND_demo_05.png" %}
<h2 id="8">The incomplete dislocation density tensor</h2><p>According to Kroener the curvature tensor is directly related to the dislocation density tensor.</p>
{% highlight matlab %}
alpha = kappa.dislocationDensity
{% endhighlight %}

{% highlight plaintext %}
 
alpha = dislocationDensityTensor  
  size: 101 x 51 
  unit: 1/um     
  rank: 2 (3 x 3)

{% endhighlight %}
<p>which has the same unit as the curvature tensor and is incomplete as well as we can see when looking at a particular one.</p>
{% highlight matlab %}
alpha(2,3)
{% endhighlight %}

{% highlight plaintext %}
 
ans = dislocationDensityTensor  
  unit: 1/um     
  rank: 2 (3 x 3)
 
 *10^-4
     NaN  -5.178 -12.003
  15.127     NaN  16.171
     NaN     NaN   -3.26

{% endhighlight %}
<h2 id="10">Crystallographic Dislocations</h2><p>The central idea of Pantleon is that the dislocation density tensor is build up by single dislocations with different densities such that the total energy is minimum. Depending on the attomic lattice different dislocattion systems have to be considered. In present case of a body centered cubic (bcc) material 48 edge dislocations and 4 screw dislocations have to be considered. Those principle dislocations are defined in MTEX either by their Burgers and line vectors or by</p>
{% highlight matlab %}
dS = dislocationSystem.bcc(ebsd.CS)
{% endhighlight %}

{% highlight plaintext %}
 
dS = dislocationSystem  
 mineral: Iron (Alpha) (432)
 edge dislocations : 48 x 1
 Burgers vector  line vector  energy
      [1 -1  1]   (-2 -1  1)       2
      [1  1 -1]    (2 -1  1)       2
      [1  1 -1]    (1 -2 -1)       2
     [-1  1  1]    (1  2 -1)       2
      [1 -1  1]   (-1  1  2)       2
     [-1  1  1]   (-1  1 -2)       2
      [1 -1  1]    (1  2  1)       2
      [1  1  1]   (-1  2 -1)       2
      [1  1 -1]    (1  1  2)       2
      [1  1  1]   (-1 -1  2)       2
     [-1  1  1]    (2  1  1)       2
      [1  1  1]    (2 -1 -1)       2
     [-1  1  1]    (0  1 -1)       2
      [1 -1  1]   (-1  0  1)       2
      [1  1 -1]    (1 -1  0)       2
     [-1  1  1]   (-1  0 -1)       2
      [1 -1  1]   (-1 -1  0)       2
      [1  1 -1]    (0 -1 -1)       2
      [1  1 -1]    (1  0  1)       2
     [-1  1  1]    (1  1  0)       2
      [1 -1  1]    (0  1  1)       2
     [-1 -1 -1]    (0 -1  1)       2
     [-1 -1 -1]    (1  0 -1)       2
     [-1 -1 -1]   (-1  1  0)       2
     [-1  1  1]   (-1  4 -5)       2
      [1 -1  1]   (-5 -1  4)       2
      [1  1 -1]    (4 -5 -1)       2
     [-1  1  1]   (-4  1 -5)       2
      [1 -1  1]   (-5 -4  1)       2
      [1  1 -1]    (1 -5 -4)       2
      [1  1 -1]    (4  1  5)       2
     [-1  1  1]    (5  4  1)       2
      [1 -1  1]    (1  5  4)       2
     [-1 -1 -1]   (-1 -4  5)       2
     [-1 -1 -1]    (5 -1 -4)       2
     [-1 -1 -1]   (-4  5 -1)       2
      [1 -1  1]    (1 -4 -5)       2
      [1  1 -1]   (-5  1 -4)       2
     [-1  1  1]   (-4 -5  1)       2
      [1 -1  1]    (4 -1 -5)       2
      [1  1 -1]   (-5  4 -1)       2
     [-1  1  1]   (-1 -5  4)       2
     [-1 -1 -1]   (-4 -1  5)       2
     [-1 -1 -1]    (5 -4 -1)       2
     [-1 -1 -1]   (-1  5 -4)       2
      [1  1 -1]    (1  4  5)       2
     [-1  1  1]    (5  1  4)       2
      [1 -1  1]    (4  5  1)       2
 
 screw dislocations: 4 x 1
 Burgers vector  energy
     (-1 -1 -1)       1
      (1 -1  1)       1
     (-1  1  1)       1
      (1  1 -1)       1
 

{% endhighlight %}
<p>Here the norm of the Burgers vectors is important</p>
{% highlight matlab %}
% size of the unit cell
a = norm(ebsd.CS.aAxis);

% in bcc and fcc the norm of the burgers vector is sqrt(3)/2 * a
[norm(dS(1).b), norm(dS(end).b), sqrt(3)/2 * a]
{% endhighlight %}

{% highlight plaintext %}
ans =
    2.4855    2.4855    2.4855

{% endhighlight %}
<h2 id="12">The Energy of Dislocations</h2><p>The energy of each dislocation system can be stored in the property <tt>u</tt>. By default this value it set to 1 but should be changed accoring to the specific model and the specific material.</p><p>According to Hull &amp; Bacon the energy U of edge and screw dislocations is given by the formulae</p><p>
  {% include inline_image.html file="GND_demo_eq10151767036785061618.png" %}
</p><p>
  {% include inline_image.html file="GND_demo_eq06307640569981345809.png" %}
</p><p>where</p><div><ul><li><tt>G</tt> is</li><li><tt>b</tt> is the length of the Burgers vector</li><li><tt>nu</tt> is the Poisson ratio</li><li><tt>R</tt></li><li><tt>r</tt></li></ul></div><p>In this example we assume</p>
{% highlight matlab %}
%
%R =
%r_0 =
%U = norm(dS.b).^2

nu = 0.3;


% energy of the edge dislocations
dS(dS.isEdge).u = 1;

% energy of the screw dislocations
dS(dS.isScrew).u = 1 - 0.3;

% Question to verybody: what is the best way to set the enegry? I found
% different formulae
%
% E = 1 - poisson ratio
% E = c * G * |b|^2,  - G - Schubmodul / Shear Modulus Energy per (unit length)^2
{% endhighlight %}
<p>A single dislocation causes a deformation that can be represented by the rank one tensor</p>
{% highlight matlab %}
dS(1).tensor
{% endhighlight %}

{% highlight plaintext %}
 
ans = dislocationDensityTensor  
  unit   : au                
  rank   : 2 (3 x 3)         
  mineral: Iron (Alpha) (432)
 
 -1.1717 -0.5858  0.5858
  1.1717  0.5858 -0.5858
 -1.1717 -0.5858  0.5858

{% endhighlight %}
<p>Note that the unit of this tensors is the same as the unit used for describing the length of the unit cell, which is in most cases Angstrom (au). Furthremore, we observe that the tensor is given with respect to the crystal reference frame while the dislocation densitiy tensors are given with respect to the specimen reference frame. Hence, to make them compatible we have to rotate the dislocation tensors into the specimen reference frame as well. This is done by</p>
{% highlight matlab %}
dSRot = ebsd.orientations * dS
{% endhighlight %}

{% highlight plaintext %}
 
dSRot = dislocationSystem  
 edge dislocations : 5144 x 48
 screw dislocations: 5144 x 4

{% endhighlight %}
<h2 id="15">Fitting Dislocations to the incomplete dislocation density tensor</h2><p>Now we are ready for fitting the dislocation tensors to the dislocation densitiy tensor in each pixel of the map. This is done by the command <a href="curvatureTensor.fitDislocationSystems.html">fitDislocationSystems</a>.</p>
{% highlight matlab %}
[rho,factor] = fitDislocationSystems(kappa,dSRot);
{% endhighlight %}

{% highlight plaintext %}

Optimal solution found.

 fitting: 100%

{% endhighlight %}
<p>As result we obtain a matrix of densities <tt>rho</tt> such that the product with the dislocation systems yields the incomplete dislocation density tensors derived from the curvature, i.e.,</p>
{% highlight matlab %}
% the restored dislocation density tensors
alpha = sum(dSRot.tensor .* rho,2);

% we have to set the unit manualy since it is not stored in rho
alpha.opt.unit = '1/um';

% the restored dislocation density tensor for pixel 2
alpha(2)

% the dislocation density dervied from the curvature in pixel 2
kappa(2).dislocationDensity
{% endhighlight %}

{% highlight plaintext %}
 
ans = dislocationDensityTensor  
  unit: 1/um     
  rank: 2 (3 x 3)
 
 *10^-5
 -22.73   1.96 -29.17
  48.71   6.38  44.63
  -5.15   1.79   5.26
 
ans = dislocationDensityTensor  
  unit: 1/um     
  rank: 2 (3 x 3)
 
 *10^-5
    NaN   1.96 -29.17
  48.71    NaN  44.63
    NaN    NaN   5.26

{% endhighlight %}
<p>we may also restore the complete curvature tensor with</p>
{% highlight matlab %}
kappa = alpha.curvature
{% endhighlight %}

{% highlight plaintext %}
 
kappa = curvatureTensor  
  size: 5151 x 1 
  unit: 1/um     
  rank: 2 (3 x 3)

{% endhighlight %}
<p>and plot it as we did before</p>
{% highlight matlab %}
newMtexFigure('nrows',3,'ncols',3);

% cycle through all components of the tensor
for i = 1:3
  for j = 1:3

    nextAxis(i,j)
    plot(ebsd,kappa{i,j},'micronBar','off')
    hold on; plot(grains.boundary,'linewidth',2); hold off

  end
end

setColorRange([-0.005,0.005])
drawNow(gcm,'figSize','large');
{% endhighlight %}

  {% include inline_image.html file="GND_demo_06.png" %}
<h2 id="19">The total dislocation energy</h2><p>The unit of the densities <tt>h</tt> in our example is 1/um * 1/au where 1/um comes from the unit of the curvature tensor an 1/au from the unit of the Burgers vector. In order to transform <tt>h</tt> to SI units, i.e., 1/m^2 we have to multiply it with 10^16. This is exactly the values returned as the second output <tt>factor</tt> by the function <a href="curvatureTensor.fitDislocationSystems.html">fitDislocationSystems</a>.</p>
{% highlight matlab %}
factor
{% endhighlight %}

{% highlight plaintext %}
factor =
   1.0000e+16

{% endhighlight %}
<p>Multiplying the densities <tt>rho</tt> with this factor and the individual energies of the the dislocation systems we end up with the total dislocation energy. Lets plot this at a logarithmic scale</p>
{% highlight matlab %}
close all
plot(ebsd,factor*sum(abs(rho .* dSRot.u),2),'micronbar','off')
mtexColorMap('hot')
mtexColorbar

set(gca,'ColorScale','log'); % this works only starting with Matlab 2018a
set(gca,'CLim',[1e11 5e14]);

hold on
plot(grains.boundary,'linewidth',2)
hold off
{% endhighlight %}

  {% include inline_image.html file="GND_demo_07.png" %}

{% highlight matlab %}
plotx2east
{% endhighlight %}
</div></body></html>