---
title: Rotations (The Class [[rotation_index.html,rotation]])
last_updated: 05-Mar-2019
sidebar: documentation_sidebar
permalink: rotation_index.html
folder: documentation_matlab
toc: false
---

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Rotations (The Class [[rotation_index.html,rotation]])</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-03-05"><meta name="DC.source" content="script_rotation_index.m"></head><body><font size="2"><a href="#" data-toggle="tooltip" data-original-title="To edit this page type edit rotation_index into the Matlab commandline">edit page</a></font><div><!--introduction--><p>This section describes the class  <a href="rotation.rotation.html"><b>rotation</b></a> and gives an overview on how to work with rotations in MTEX.</p><!--/introduction--><h2 id="1">Open in Editor</h2><h2 id="2">Contents</h2><h2 id="3">Class Description</h2><p>The class <b>rotation</b> is an inheritance of the class <a href="quaternion_index.html"><b>quaternion</b></a> and allow to work with rotations as with matrixes in MTEX.</p><h2 id="4">SUB: Euler Angle Conventions</h2><p>There are several ways to specify a rotation in MTEX. A well-known possibility are the so called <b>Euler angles</b>. In texture analysis the following conventions are commonly used</p><div><ul><li>Bunge (phi1,Phi,phi2)       - ZXZ</li><li>Matthies (alpha,beta,gamma) - ZYZ</li><li>Roe (Psi,Theta,Phi)</li><li>Kocks (Psi,Theta,phi)</li><li>Canova (omega,Theta,phi)</li></ul></div><p><b>Defining a Rotation by Bunge Euler Angles</b></p><p>The default Euler angle convention in MTEX are the Bunge Euler angles. Here a rotation is determined by three consecutive rotations, the first about the z-axis, the second about the y-axis, and the third again about the z-axis. Hence, one needs three angles to define an rotation by Euler angles. The following command defines a rotation by its three Bunge Euler angles</p><pre class="codeinput">o = rotation.byEuler(30*degree,50*degree,10*degree)
</pre><p><b>Defining a Rotation by Other Euler Angle Conventions</b></p><p>In order to define a rotation by a Euler angle convention different to the default Euler angle convention you to specify the convention as an additional parameter, e.g.</p><pre class="codeinput">o = rotation.byEuler(30*degree,50*degree,10*degree,<span class="string">'Roe'</span>)
</pre><p><b>Changing the Default Euler Angle Convention</b></p><p>The default euler angle convention can be changed by the command <b>setpref</b>, for a permanent change the <a href="matlab:edit('mtex_settings.m')">mtex_settings</a> should be edited. Compare</p><pre class="codeinput">setMTEXpref(<span class="string">'EulerAngleConvention'</span>,<span class="string">'Roe'</span>)
o
</pre><pre class="codeinput">setMTEXpref(<span class="string">'EulerAngleConvention'</span>,<span class="string">'Bunge'</span>)
o
</pre><h2 id="8">SUB: Other Ways of Defining a Rotation</h2><p><b>The axis angle parametrisation</b></p><p>A very simple possibility to specify a rotation is to specify the rotational axis and the rotational angle.</p><pre class="codeinput">o = rotation.byAxisAngle(xvector,30*degree)
</pre><p><b>Four vectors defining a rotation</b></p><p>Given four vectors u1, v1, u2, v2 there is a unique rotations q such that q u1 = v1 and q u2 = v2.</p><pre class="codeinput">o = rotation.map(xvector,yvector,zvector,zvector)
</pre><p>If only two vectors are specified the rotation with the smallest angle is returned that maps the first vector onto the second one.</p><pre class="codeinput">o = rotation.map(xvector,yvector)
</pre><p><b>A fibre of rotations</b></p><p>The set of all rotations that rotate a certain vector u onto a certain vector v define a fibre in the rotation space. A discretisation of such a fibre is defined by</p><pre class="codeinput">u = xvector;
v = yvector;
o = rotation(fibre(u,v))
</pre><p><b>Defining a rotation by a 3 times 3 matrix</b></p><pre class="codeinput">o = rotation.byMatrix(eye(3))
</pre><p><b>Defining a rotation by a quaternion</b></p><p>A last possibility is to define a rotation by a quaternion, i.e., by its components a,b,c,d.</p><pre class="codeinput">o = rotation(quaternion(1,0,0,0))
</pre><p>Actually, MTEX represents internally every rotation as a quaternion. Hence, one can write</p><pre class="codeinput">q = quaternion(1,0,0,0)
o = rotation(q)
</pre><h2 id="15">SUB: Calculating with Rotations</h2><p><b>Rotating Vectors</b></p><p>Let</p><pre class="codeinput">o = rotation.byEuler(90*degree,90*degree,0*degree)
</pre><p>a certain rotation. Then the rotation of the xvector is computed via</p><pre class="codeinput">v = o * xvector
</pre><p>The inverse rotation is computed via the <a href="rotation.mldivide.html">backslash operator</a></p><pre class="codeinput">o \ v
</pre><p><b>Concatenating Rotations</b></p><p>Let</p><pre class="codeinput">rot1 = rotation.byEuler(90*degree,0,0);
rot2 = rotation.byEuler(0,60*degree,0);
</pre><p>be two rotations. Then the rotation defined by applying first rotation one and then rotation two is computed by</p><pre class="codeinput">rot = rot2 * rot1
</pre><p><b>Computing the rotation angle and the rotational axis</b></p><p>Then rotational angle and the axis of rotation can be computed via then commands <a href="quaternion.angle.html">angle(rot)</a> and <a href="quaternion.axis.html">axis(rot)</a></p><pre class="codeinput">angle(rot)/degree

axis(rot)
</pre><p>If two rotations are specified the command <a href="quaternion.angle.html">angle(rot1,rot2)</a> computes the rotational angle between both rotations</p><pre class="codeinput">angle(rot1,rot2)/degree
</pre><p><b>The inverse Rotation</b></p><p>The inverse rotation you get from the command <a href="quaternion.inv.html">inv(rot)</a></p><pre class="codeinput">inv(rot)
</pre><h2 id="23">SUB: Conversion into Euler Angles and Rodrigues Parametrisation</h2><p>There are methods to transform quaternion in almost any other parameterization of rotations as they are:</p><div><ul><li>[[quaternion.Euler.html,Euler(rot)]]   in Euler angle</li><li>[[quaternion.Rodrigues.html,Rodrigues(rot)]] % in Rodrigues parameter</li></ul></div><pre class="codeinput">[alpha,beta,gamma] = Euler(rot,<span class="string">'Matthies'</span>)
</pre><h2 id="24">SUB: Plotting Rotations</h2><p>The <a href="quaternion.plot.html">plot</a> function allows you to visualize an rotation by plotting how the standard basis x,y,z transforms under the rotation.</p><pre class="codeinput">plot(rot)
</pre><h2 id="25">Complete Function list</h2><p><table width="90%"><tr><td width="200px"><a href="rotation.byAxisAngle.html"><tt>byAxisAngle</tt></a></td><td>define rotations by rotational axis and rotational angle</td></tr><tr><td width="200px"><a href="rotation.byEuler.html"><tt>byEuler</tt></a></td><td>define rotentations by Euler angles</td></tr><tr><td width="200px"><a href="rotation.byMatrix.html"><tt>byMatrix</tt></a></td><td>define rotations by matrices</td></tr><tr><td width="200px"><a href="rotation.char.html"><tt>char</tt></a></td><td>quaternion to char</td></tr><tr><td width="200px"><a href="rotation.display.html"><tt>display</tt></a></td><td>standart output</td></tr><tr><td width="200px"><a href="rotation.dot.html"><tt>dot</tt></a></td><td>compute rot1 . rot2</td></tr><tr><td width="200px"><a href="rotation.dot_outer.html"><tt>dot_outer</tt></a></td><td/></tr><tr><td width="200px"><a href="rotation.line.html"><tt>line</tt></a></td><td>draw rotations connected by lines</td></tr><tr><td width="200px"><a href="rotation.map.html"><tt>map</tt></a></td><td>define rotations by pairs of vectors</td></tr><tr><td width="200px"><a href="rotation.matrix.html"><tt>matrix</tt></a></td><td>quaternion to direction cosine matrix conversion</td></tr><tr><td width="200px"><a href="rotation.mldivide.html"><tt>mldivide</tt></a></td><td>o \ v </td></tr><tr><td width="200px"><a href="rotation.mtimes.html"><tt>mtimes</tt></a></td><td>r = a * b</td></tr><tr><td width="200px"><a href="rotation.permute.html"><tt>permute</tt></a></td><td>overloads permute</td></tr><tr><td width="200px"><a href="rotation.power.html"><tt>power</tt></a></td><td>r.^n</td></tr><tr><td width="200px"><a href="rotation.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a></td><td>projects rotation to a fundamental region</td></tr><tr><td width="200px"><a href="rotation.repmat.html"><tt>repmat</tt></a></td><td>overloads repmat</td></tr><tr><td width="200px"><a href="rotation.reshape.html"><tt>reshape</tt></a></td><td>overloads reshape</td></tr><tr><td width="200px"><a href="rotation.rotation.html"><tt>rotation</tt></a></td><td>defines an rotation</td></tr><tr><td width="200px"><a href="rotation.subSet.html"><tt>subSet</tt></a></td><td>indexing of rotation</td></tr><tr><td width="200px"><a href="rotation.subsasgn.html"><tt>subsasgn</tt></a></td><td>overloads subsasgn</td></tr><tr><td width="200px"><a href="rotation.subsref.html"><tt>subsref</tt></a></td><td>overloads subsref</td></tr><tr><td width="200px"><a href="rotation.times.html"><tt>times</tt></a></td><td>r = a .* b</td></tr><tr><td width="200px"><a href="rotation.transpose.html"><tt>transpose</tt></a></td><td>array of rotations</td></tr><tr><td width="200px"><a href="rotation.uminus.html"><tt>uminus</tt></a></td><td>implements rotation</td></tr><tr><td width="200px"><a href="rotation.unique.html"><tt>unique</tt></a></td><td>disjoint list of rotations</td></tr></table></p></div></body></html>